<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Oak Insights</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
:root {
    --tab-bar-height: 54px;
    --crt-header-height: 0px;
    --accent-color: #4a6ef5;
    --accent-soft: rgba(74, 110, 245, 0.22);
    --surface-elevated: #1f1f1f;
    --surface-raised: #242424;
    --border-color: #333;
    --text-muted: #a6a6a6;
}
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #1e1e1e;
            color: #d4d4d4;
            overflow: hidden;
        }
        .crt-panel-header {
            display: none;
            padding: 10px 20px;
            background: #2d2d2d;
            border-bottom: 1px solid #3d3d3d;
            align-items: center;
            justify-content: space-between;
            z-index: 100;
        }
        .main-content.crt-active .crt-panel-header {
            display: flex;
        }
        .main-content.crt-active {
            --crt-header-height: 56px;
        }
        .header-left {
            display: flex;
            align-items: center;
        }
        .crt-panel-header h1 {
            margin: 0;
            color: #fff;
            font-size: 20px;
        }
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }
        .crt-actions {
            display: flex;
            align-items: center;
            gap: 6px;
        }
.editor-container {
    position: absolute;
    top: calc(var(--tab-bar-height) + var(--crt-header-height));
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    flex-direction: column;
}
.edit-tabs {
    display: flex;
    gap: 8px;
    padding: 8px 16px;
    align-items: center;
    background: #1e1e1e;
    border-bottom: 1px solid #2f2f2f;
    position: relative;
    z-index: 2;
    height: var(--tab-bar-height);
    box-sizing: border-box;
}
.edit-tab-button {
    background: #2a2a2a;
    border: 1px solid #3a3a3a;
    color: #d4d4d4;
    padding: 6px 14px;
    border-radius: 6px 6px 0 0;
    cursor: pointer;
    font-size: 13px;
    letter-spacing: 0.3px;
}
.edit-tab-button:hover {
    background: #323232;
}
.edit-tab-button.active {
    background: #363636;
    border-bottom-color: #1e1e1e;
    color: #fff;
}
.edit-tab-button:disabled,
.edit-tab-button.disabled {
    background: #1e1e1e;
    border-color: #2c2c2c;
    color: var(--text-muted);
    cursor: not-allowed;
    opacity: 0.6;
}
.edit-tab-button:disabled:hover,
.edit-tab-button.disabled:hover {
    background: #1e1e1e;
}
.edit-tab-content {
    display: none;
    flex: 1;
    overflow: hidden;
}
.edit-tab-content.active {
    display: flex;
}
.editor-container .text-editor-wrapper {
    display: flex;
    flex: 1;
    background: #1e1e1e;
}
.editor-container .text-editor-wrapper.hidden {
    display: none;
}
.editor-container .refine-view {
    flex: 1;
    display: none;
    flex-direction: column;
    background: #1e1e1e;
    color: #d4d4d4;
}
.editor-container.show-refine .text-editor-wrapper {
    display: none;
}
.editor-container.show-refine .refine-view {
    display: flex;
}
        .refine-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid #3d3d3d;
            background: #252525;
        }
        .refine-grid {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            padding: 16px;
            overflow: auto;
        }
        .refine-column {
            background: #202020;
            border: 1px solid #333;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .refine-column h3 {
            margin: 0;
            padding: 10px 14px;
            font-size: 14px;
            background: #292929;
            border-bottom: 1px solid #333;
        }
        .refine-text {
            padding: 12px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            line-height: 1.45;
            white-space: pre-wrap;
            overflow: auto;
            flex: 1;
            margin: 0;
            background: transparent;
            color: #d4d4d4;
        }
        .refine-actions {
            padding: 12px 14px;
            border-bottom: 1px solid #333;
            font-size: 13px;
            color: #bbb;
        }
        .refine-list {
            padding: 10px 14px;
            overflow-y: auto;
            flex: 1;
        }
        .refine-entity-item,
        .refine-link-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 8px;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            margin-bottom: 8px;
            background: #262626;
        }
        .refine-item-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .refine-item-id {
            font-weight: bold;
            color: #8ab4ff;
        }
        .refine-item-text {
            font-size: 13px;
            color: #dcdcdc;
        }
        .refine-item-meta {
            font-size: 12px;
            color: #aaa;
        }
        .visualization-container {
            position: absolute;
            top: calc(var(--tab-bar-height) + var(--crt-header-height));
            left: 0;
            right: 0;
            bottom: 0;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            background: #fff;
        }
        .show-visualization .crt-workspace {
            transform: translateX(-100%);
        }
        .show-visualization .visualization-container {
            transform: translateX(0);
        }
        .line-numbers {
            padding: 10px;
            background: #2d2d2d;
            color: #858585;
            text-align: right;
            user-select: none;
            border-right: 1px solid #3d3d3d;
            min-width: 40px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre;
        }
        textarea {
            flex: 1;
            padding: 10px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.5;
            background: #1e1e1e;
            color: #d4d4d4;
            border: none;
            resize: none;
            outline: none;
            tab-size: 4;
        }
        .icon-button {
            background: transparent;
            border: none;
            color: #d4d4d4;
            cursor: pointer;
            padding: 8px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: background-color 0.2s;
        }
        .icon-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        .icon-button:disabled,
        .icon-button.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
.icon-button .material-icons {
    font-size: 24px;
}
.edit-tab-content#crt-tab {
    flex-direction: column;
    overflow: hidden;
}
.crt-panel-header {
    flex: 0 0 auto;
}
.crt-workspace {
    flex: 1 1 auto;
    display: flex;
    min-height: 0;
    transition: transform 0.3s ease;
}
.edit-tab-content#dora-tab {
    flex-direction: column;
    align-items: center;
    padding: 36px 32px 40px;
    gap: 32px;
    overflow-y: auto;
    color: #d4d4d4;
}
.edit-tab-content#time-tab {
    flex-direction: column;
    padding: 20px;
    gap: 24px;
    overflow-y: auto;
    color: #d4d4d4;
}
.dora-content {
    width: min(960px, 100%);
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    gap: 32px;
    align-items: stretch;
}
.dora-table-card,
.westrum-card {
    background: var(--surface-elevated);
    border: 1px solid var(--border-color);
    border-radius: 16px;
    padding: 28px 32px;
    box-shadow: 0 18px 32px rgba(0, 0, 0, 0.35);
    display: flex;
    flex-direction: column;
    gap: 24px;
}
.dora-card-header {
    display: flex;
    flex-direction: column;
    gap: 6px;
}
.dora-card-header h2 {
    margin: 0;
    font-size: 22px;
    letter-spacing: 0.4px;
}
.dora-card-header p {
    margin: 0;
    color: var(--text-muted);
    font-size: 13px;
}
.dora-table {
    display: grid;
    width: 100%;
    grid-template-columns: minmax(220px, 1.15fr) repeat(4, minmax(0, 1fr));
    grid-auto-rows: minmax(52px, auto);
    background: var(--surface-raised);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    overflow: hidden;
}
.dora-table-header {
    padding: 12px;
    background: #2f2f2f;
    font-weight: bold;
    text-transform: uppercase;
    font-size: 12px;
    letter-spacing: 0.6px;
    text-align: center;
    border-right: 1px solid var(--border-color);
    color: #bbb;
}
.dora-table-header:first-child {
    background: transparent;
    text-align: left;
}
.dora-table-header:last-child {
    border-right: none;
}
.dora-metric {
    padding: 14px;
    border-top: 1px solid var(--border-color);
    border-right: 1px solid var(--border-color);
    color: #fff;
    font-weight: 600;
    font-size: 13px;
    background: #202020;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    line-height: 1.4;
}
.dora-table .dora-metric:first-of-type {
    border-top: none;
}
.dora-table .dora-cell:nth-of-type(-n+4) {
    border-top: none;
}
.dora-cell {
    border: none;
    background: #1c1c1c;
    color: #d4d4d4;
    border-top: 1px solid var(--border-color);
    border-right: 1px solid var(--border-color);
    padding: 14px 16px;
    text-align: center;
    font-size: 13px;
    cursor: pointer;
    transition: background 0.2s, color 0.2s, box-shadow 0.2s;
    line-height: 1.4;
    word-break: break-word;
}
.dora-cell:focus-visible {
    outline: 2px solid #7ea0ff;
    outline-offset: -2px;
}
.dora-cell:last-child {
    border-right: none;
}
.dora-cell:hover {
    background: #2a2a2a;
}
.dora-cell.active {
    background: var(--accent-soft);
    color: #fff;
    box-shadow: inset 0 0 0 1px var(--accent-color);
    font-weight: 600;
}
.dora-input {
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 18px 20px;
    background: #1c1c1c;
    border: 1px solid var(--border-color);
    border-radius: 12px;
}
.dora-input label {
    font-weight: 600;
    font-size: 13px;
    color: #fff;
}
.dora-input input {
    background: #111;
    border: 1px solid #3a3a3a;
    border-radius: 8px;
    padding: 10px 12px;
    color: #e6e6e6;
    font-size: 14px;
}
.dora-input input:focus {
    outline: none;
    border-color: var(--accent-color);
    box-shadow: 0 0 0 2px rgba(74, 110, 245, 0.25);
}
.dora-input input::placeholder {
    color: var(--text-muted);
}
.dora-input .dora-input-hint {
    font-size: 12px;
    color: var(--text-muted);
    line-height: 1.5;
}
.westrum-card-header {
    display: flex;
    justify-content: space-between;
    gap: 16px;
    align-items: center;
    flex-wrap: wrap;
}
.westrum-card-header h3 {
    margin: 0;
    font-size: 20px;
}
.westrum-card-header p {
    margin: 6px 0 0;
    color: var(--text-muted);
    font-size: 13px;
    max-width: 520px;
}
.westrum-label-pill {
    padding: 6px 16px;
    border-radius: 999px;
    background: rgba(78, 110, 245, 0.2);
    color: #b5c6ff;
    font-weight: 600;
    font-size: 13px;
    letter-spacing: 0.4px;
}
.westrum-slider-wrap {
    padding: 0 6px 12px;
}
.westrum-slider-wrap input[type="range"] {
    width: 100%;
    -webkit-appearance: none;
    appearance: none;
    height: 6px;
    border-radius: 999px;
    background: linear-gradient(90deg, rgba(74, 110, 245, 0.25), rgba(74, 110, 245, 0.65));
    outline: none;
    cursor: pointer;
}
.westrum-slider-wrap input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #fff;
    border: 2px solid var(--accent-color);
    box-shadow: 0 0 0 3px rgba(74, 110, 245, 0.2);
    transition: transform 0.2s ease;
}
.westrum-slider-wrap input[type="range"]::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #fff;
    border: 2px solid var(--accent-color);
    box-shadow: 0 0 0 3px rgba(74, 110, 245, 0.2);
    transition: transform 0.2s ease;
}
.westrum-slider-wrap input[type="range"]::-webkit-slider-thumb:hover,
.westrum-slider-wrap input[type="range"]::-moz-range-thumb:hover {
    transform: scale(1.05);
}
.westrum-scale-steps {
    display: grid;
    width: 100%;
    grid-template-columns: repeat(7, minmax(0, 1fr));
    gap: 12px;
}
.westrum-step {
    background: #252525;
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 12px 14px;
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    color: #d4d4d4;
    cursor: pointer;
    transition: border-color 0.2s, background 0.2s, box-shadow 0.2s;
    min-height: 82px;
}
.westrum-step:hover {
    border-color: rgba(126, 160, 255, 0.6);
}
.westrum-step.active {
    border-color: var(--accent-color);
    background: var(--accent-soft);
    box-shadow: inset 0 0 0 1px rgba(126, 160, 255, 0.6);
}
.westrum-step-index {
    font-size: 12px;
    font-weight: 600;
    opacity: 0.7;
}
.westrum-step-text {
    font-size: 13px;
    font-weight: 600;
    line-height: 1.35;
}
.time-content {
    width: min(960px, 100%);
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    gap: 32px;
    align-items: stretch;
}
.time-card {
    background: var(--surface-elevated);
    border: 1px solid var(--border-color);
    border-radius: 16px;
    padding: 28px 32px;
    box-shadow: 0 18px 32px rgba(0, 0, 0, 0.35);
    display: flex;
    flex-direction: column;
    gap: 24px;
}
.time-card-header {
    display: flex;
    justify-content: space-between;
    gap: 16px;
    align-items: center;
    flex-wrap: wrap;
}
.time-card-header h2 {
    margin: 0;
    font-size: 22px;
    letter-spacing: 0.4px;
}
.time-card-header p {
    margin: 0;
    color: var(--text-muted);
    font-size: 13px;
    max-width: 520px;
}
.time-progress {
    width: 100%;
    height: 10px;
    background: #161616;
    border-radius: 999px;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.05);
}
.time-progress-bar {
    height: 100%;
    width: 0;
    background: var(--accent-color);
    border-radius: inherit;
    transition: width 0.2s ease, background 0.2s ease;
}
.time-progress-bar.overallocated {
    background: #ff6b6b;
}
.time-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 16px;
}
.time-item {
    background: var(--surface-raised);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 16px 18px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    position: relative;
}
.time-item label {
    font-size: 13px;
    font-weight: 600;
    color: #fff;
}
.time-lock-badge {
    position: absolute;
    top: 12px;
    right: 16px;
    display: none;
    align-items: center;
    gap: 4px;
    font-size: 11px;
    font-weight: 600;
    background: var(--accent-soft);
    color: var(--accent-color);
    border-radius: 999px;
    padding: 4px 8px;
    pointer-events: none;
}
.time-lock-badge .material-icons {
    font-size: 16px;
    line-height: 1;
}
.time-item.locked .time-lock-badge {
    display: inline-flex;
}
.time-item-hint {
    font-size: 12px;
    color: var(--text-muted);
}
.time-lock {
    display: flex;
    justify-content: flex-start;
    align-items: center;
    gap: 6px;
    font-size: 11px;
    color: var(--text-muted);
}
.time-lock label {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    cursor: pointer;
}
.time-lock input[type="checkbox"] {
    accent-color: var(--accent-color);
}
.time-input-group {
    display: flex;
    align-items: center;
    gap: 8px;
}
.time-input-group input[type="number"] {
    flex: 0 0 70px;
    background: #151515;
    border: 1px solid #3a3a3a;
    border-radius: 8px;
    padding: 6px 10px;
    color: #e0e0e0;
    font-size: 14px;
}
.time-slider {
    flex: 1;
    margin-bottom: 6px;
}
.time-slider input[type="range"] {
    width: 100%;
    -webkit-appearance: none;
    appearance: none;
    height: 6px;
    border-radius: 999px;
    background: linear-gradient(90deg, var(--accent-color) 0%, rgba(255, 255, 255, 0.08) 0%);
    outline: none;
    cursor: pointer;
}
.time-slider input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #fff;
    border: 2px solid var(--accent-color);
    box-shadow: 0 0 0 3px rgba(74, 110, 245, 0.2);
}
.time-slider input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #fff;
    border: 2px solid var(--accent-color);
    box-shadow: 0 0 0 3px rgba(74, 110, 245, 0.2);
}
.time-input-suffix {
    font-size: 13px;
    color: var(--text-muted);
}
.analysis-content {
    display: flex;
    flex-direction: column;
    gap: 24px;
    width: 100%;
}
.analysis-card {
    background: var(--surface-elevated);
    border: 1px solid var(--border-color);
    border-radius: 16px;
    padding: 28px 32px;
    box-shadow: 0 18px 32px rgba(0, 0, 0, 0.35);
    display: flex;
    flex-direction: column;
    gap: 20px;
}
.analysis-card-header {
    display: flex;
    flex-wrap: wrap;
    gap: 16px;
    justify-content: space-between;
    align-items: flex-start;
}
.analysis-card-header h2 {
    margin: 0;
    font-size: 22px;
    letter-spacing: 0.4px;
}
.analysis-card-header p {
    margin: 0;
    color: var(--text-muted);
    font-size: 13px;
    max-width: 520px;
}
.analysis-status {
    font-size: 12px;
    color: var(--text-muted);
    padding: 6px 10px;
    border-radius: 999px;
    background: rgba(255, 255, 255, 0.05);
    align-self: flex-start;
}
.analysis-status.running {
    color: var(--accent-color);
    background: rgba(74, 110, 245, 0.12);
}
.analysis-status.warning {
    color: #f6c177;
    background: rgba(246, 193, 119, 0.16);
}
.analysis-status.error {
    color: #ff8f8f;
    background: rgba(255, 107, 107, 0.18);
}
.analysis-actions {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
}
.analysis-actions button {
    background: var(--accent-color);
    color: #fff;
    border: none;
    padding: 8px 16px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 13px;
    letter-spacing: 0.3px;
    display: inline-flex;
    align-items: center;
    gap: 8px;
}
.analysis-actions button:disabled {
    background: #2f2f2f;
    color: var(--text-muted);
    cursor: not-allowed;
}
.analysis-output {
    background: #151515;
    border: 1px solid #2f2f2f;
    border-radius: 12px;
    padding: 18px;
    font-size: 13px;
    line-height: 1.6;
    overflow: auto;
    max-height: 360px;
    display: flex;
    flex-direction: column;
    gap: 12px;
}
.analysis-output p {
    margin: 0;
}
.analysis-output ul {
    margin: 8px 0 0 18px;
    padding: 0;
    list-style: disc;
}
.analysis-output li {
    margin-bottom: 4px;
}
.analysis-section-title {
    font-weight: 600;
    color: #fff;
}
.analysis-section {
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.analysis-subsection {
    display: flex;
    flex-direction: column;
    gap: 6px;
}
.analysis-subsection .analysis-key {
    margin: 0;
    font-weight: 600;
}
.analysis-subdetail {
    font-size: 12px;
    color: var(--text-muted);
}
.analysis-subdetails {
    display: flex;
    flex-direction: column;
    gap: 4px;
    margin-top: 4px;
}
.analysis-empty {
    color: var(--text-muted);
    font-style: italic;
}
.analysis-meta {
    display: flex;
    flex-direction: column;
    gap: 8px;
    font-size: 12px;
    color: var(--text-muted);
}
.time-allocation-summary {
    font-size: 14px;
    font-weight: 600;
    color: var(--text-muted);
}
.time-allocation-summary.good {
    color: #7cbf8e;
}
.time-allocation-summary.error {
    color: #ff8a80;
}
.time-progress {
    width: 100%;
    height: 10px;
    background: #161616;
    border-radius: 999px;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.05);
}
.time-progress-bar {
    height: 100%;
    width: 0;
    background: var(--accent-color);
    border-radius: inherit;
    transition: width 0.2s ease, background 0.2s ease;
}
.time-progress-bar.overallocated {
    background: #ff6b6b;
}
.quality-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 16px;
}
.quality-pill,
.quality-note {
    background: var(--surface-raised);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 18px;
    color: #d4d4d4;
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.quality-pill h4,
.quality-note strong {
    margin: 0;
    font-size: 15px;
    letter-spacing: 0.2px;
}
.quality-pill p,
.quality-note p {
    margin: 0;
    font-size: 13px;
    color: var(--text-muted);
    line-height: 1.45;
}
        /* Visualization styles from viz.html */
        .node {
            stroke: #fff;
            stroke-width: 2px;
        }
        .node.start {
            fill: #FFD700;
        }
        .node.normal {
            fill: #E0F0FF;
        }
        .node.highlighted-primary {
            stroke: #4a90e2;
            stroke-width: 4px;
            fill: #e0f0ff;
        }
        .node.highlighted-branch {
            stroke: #4caf50;
            stroke-width: 3px;
            fill: #e0ffe0;
        }
        .node.faded {
            opacity: 0.3;
        }
        .link {
            stroke-width: 3px;
            stroke-opacity: 0.6;
        }
        .link.negated {
            stroke: #d9534f;
            stroke-dasharray: 6 3;
            stroke-opacity: 0.9;
        }
        .link.IF {
            stroke: blue;
        }
        .link.THEN {
            stroke: black;
        }
        .link.AND {
            stroke: darkgreen;
        }
        .link.highlighted {
            stroke-width: 4px;
            stroke-opacity: 1;
        }
        .link.faded {
            opacity: 0.1;
        }
        .node-label {
            font-size: 14px;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: central;
        }
        .link-label {
            font-size: 12px;
            font-weight: bold;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: text-after-edge;
            fill: #333;
            background: white;
            padding: 2px;
        }
        .link-label.negated {
            fill: #d9534f;
        }
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: #ffffff;
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 300px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            max-height: calc(100vh - 40px);
        }
        .node-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: normal;
            word-break: break-word;
            background: #ffffff;
            color: #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .node-text {
            flex: 1;
            margin-right: 8px;
        }
        .metrics-container {
            display: flex;
            gap: 4px;
            flex-shrink: 0;
        }
        .reachability-count {
            background: #4CAF50;
            color: white;
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            min-width: 20px;
            text-align: center;
            flex-shrink: 0;
        }
        .uniqueness-count {
            background: #2196F3;
            color: white;
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            min-width: 20px;
            text-align: center;
            flex-shrink: 0;
        }
        .node-item.start .reachability-count {
            background: #FF9800;
        }
        .node-item.start .uniqueness-count {
            background: #9C27B0;
        }
        .node-item:hover {
            background-color: #f0f8ff;
        }
        .node-item.selected-primary {
            background-color: #e0f0ff;
            font-weight: bold;
            border-left: 4px solid #4a90e2;
        }
        .node-item.selected-branch {
            background-color: #e0ffe0;
            border-left: 4px solid #4caf50;
        }
        .node-item.start {
            font-weight: bold;
            color: #333;
            background-color: #fff4d4;
        }
        .node-item:last-child {
            border-bottom: none;
        }
        .node-list {
            overflow-y: auto;
            max-height: 70vh;
            margin-top: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px;
            flex-grow: 1;
            background: #ffffff;
            color: #1e1e1e;
        }
        .branch-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ffffff;
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 350px;
            z-index: 1000;
            display: none;
            flex-direction: column;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            color: #1e1e1e;
        }
        .branch-panel.visible {
            display: flex;
        }
        .branch-panel h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .branch-item {
            padding: 10px;
            margin-bottom: 5px;
            border-radius: 4px;
        }
        .branch-node {
            background-color: #e0ffe0;
            border-left: 4px solid #4caf50;
        }
        .branch-node.primary {
            font-weight: bold;
            background-color: #d0e8ff;
            border-left: 4px solid #4a90e2;
        }
        .branch-relationship {
            background-color: #f8f8f8;
            color: #666;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            padding: 5px;
        }
        .tabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid #ccc;
            overflow-x: auto;
            white-space: nowrap;
            scrollbar-width: thin;
            -ms-overflow-style: none; /* IE and Edge */
        }
        .tabs::-webkit-scrollbar {
            height: 4px;
        }
        .tabs::-webkit-scrollbar-thumb {
            background-color: #ccc;
            border-radius: 2px;
        }
        .tab {
            padding: 8px 15px;
            cursor: pointer;
            border: 1px solid #ccc;
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            margin-right: 5px;
            background-color: #f5f5f5;
        }
        .tab.active {
            background-color: #fff;
            font-weight: bold;
            border-bottom: 1px solid #fff;
            margin-bottom: -1px;
        }
        .tab-content {
            display: none;
            padding: 15px;
            border: 1px solid #eee;
            border-radius: 0 0 5px 5px;
            background-color: #fff;
        }
        .tab-content.active {
            display: block;
        }
        .tooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            max-width: 300px;
            z-index: 1000;
            pointer-events: none;
        }
        #editor-title {
            margin: 0;
            color: #fff;
            font-size: 20px;
            outline: none;
            border-bottom: 1px solid transparent;
            padding: 2px 4px;
            transition: border-color 0.2s;
        }
        #editor-title:hover {
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
        }
        #editor-title:focus {
            border-bottom: 1px solid #fff;
        }
        .docs-dropdown {
            padding: 4px 8px;
            margin-right: 10px;
            background: #3d3d3d;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            outline: none;
        }
        .save-confirmation {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #4CAF50;
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s, transform 0.3s;
            z-index: 2000;
        }
        .save-confirmation.show {
            opacity: 1;
            transform: translateY(0);
        }
        .sidebar {
            position: fixed;
            top: 0;
            left: -300px;
            width: 300px;
            height: 100vh;
            background: #2d2d2d;
            z-index: 1000;
            transition: left 0.3s ease;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
        }
        .sidebar.open {
            left: 0;
        }
        .sidebar-header {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #3d3d3d;
        }
        .sidebar-header h3 {
            margin: 0;
            color: #fff;
        }
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px 0;
        }
        .doc-item {
            padding: 12px 15px;
            border-bottom: 1px solid #3d3d3d;
            cursor: pointer;
            transition: background 0.2s;
        }
        .doc-item:hover {
            background: #3d3d3d;
        }
        .doc-item-title {
            font-weight: bold;
            color: #fff;
            margin-bottom: 5px;
        }
        .doc-item-date {
            font-size: 12px;
            color: #aaa;
        }
        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            display: none;
        }
        .sidebar-overlay.open {
            display: block;
        }
        .auto-save-indicator {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(76, 175, 80, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.5s;
        }
        .auto-save-indicator.visible {
            opacity: 1;
        }
        .refine-spinner {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 10px 14px;
            border-radius: 6px;
            display: none;
            align-items: center;
            gap: 8px;
            z-index: 1500;
            font-size: 14px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        .refine-spinner.visible {
            display: flex;
        }
        .refine-spinner .spinner-icon {
            width: 18px;
            height: 18px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .doc-item.current {
            background: #4a4a4a;
            cursor: default;
            border-left: 4px solid #4CAF50;
            padding-left: 11px; /* 15px - 4px border */
        }
        .doc-item.current .doc-item-title {
            color: #fff;
        }
        .doc-item.current .doc-item-date {
            color: #bbb;
        }
    </style>
</head>
<body>
    <!-- Add this sidebar menu -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <h3>Saved Documents</h3>
            <button class="icon-button close-button" id="close-menu">
                <span class="material-icons">close</span>
            </button>
        </div>
        <div class="sidebar-content" id="saved-docs-list">
            <!-- Saved documents will be listed here -->
        </div>
    </div>

    <!-- Add an overlay for when the menu is open -->
    <div class="sidebar-overlay" id="sidebar-overlay"></div>
    <div class="refine-spinner" id="refine-spinner">
        <div class="spinner-icon"></div>
        <span>Refining…</span>
    </div>

    <div class="main-content crt-active">
            <div class="edit-tabs">
                <button class="edit-tab-button active" data-edit-tab="crt" id="crt-tab-button">CRT</button>
                <button class="edit-tab-button" data-edit-tab="dora" id="dora-tab-button">DORA Metrics</button>
                <button class="edit-tab-button" data-edit-tab="time" id="time-tab-button">Time Allocation</button>
                <button class="edit-tab-button disabled" data-edit-tab="analysis" id="analysis-tab-button" disabled>Systems Analysis</button>
            </div>
        <div class="crt-panel-header">
            <div class="header-left">
                <button class="icon-button menu-button" id="menu-button" title="Open Menu">
                    <span class="material-icons">menu</span>
                </button>
                <h1 id="editor-title" contenteditable="true" spellcheck="false">Oak Insights</h1>
            </div>
            <div class="crt-actions">
                <button class="icon-button" id="refine-button" onclick="runRefinement()" title="Refine">
                    <span class="material-icons">auto_fix_high</span>
                </button>
                <button class="icon-button" id="view-toggle-button" onclick="toggleView()" title="Toggle View">
                    <span class="material-icons" id="view-toggle-icon">account_tree</span>
                </button>
            </div>
        </div>
        <div class="editor-container">
            <div class="edit-tab-content active" id="crt-tab">
                <div class="crt-workspace">
                <div class="text-editor-wrapper" id="text-editor-wrapper">
                    <div class="line-numbers" id="line-numbers"></div>
                    <textarea id="input" placeholder="Enter CRT content here..." spellcheck="false" wrap="off"></textarea>
                </div>
                <div class="refine-view" id="refine-view">
                    <div class="refine-header">
                        <h2>Refinement Preview</h2>
                        <div>
                            <button class="icon-button" onclick="applySelectedAdditions()" id="apply-selected-button" title="Add selected suggestions to the editor">
                                <span class="material-icons">playlist_add_check</span>
                            </button>
                            <button class="icon-button" onclick="applyAllAdditions()" id="apply-all-button" title="Add all suggested entities and links">
                                <span class="material-icons">playlist_add</span>
                            </button>
                            <button class="icon-button" onclick="closeRefineView()" title="Close refinement view">
                                <span class="material-icons">close</span>
                            </button>
                        </div>
                    </div>
                    <div class="refine-grid">
                        <div class="refine-column">
                            <h3>Current CRT</h3>
                            <pre class="refine-text" id="refine-current-text"></pre>
                        </div>
                        <div class="refine-column">
                            <h3>Suggested Additions</h3>
                            <div class="refine-actions" id="refine-summary"></div>
                            <div class="refine-list" id="refine-entities-list"></div>
                            <div class="refine-list" id="refine-links-list"></div>
                        </div>
                    </div>
                </div>
                </div>
            </div>
            <div class="edit-tab-content" id="dora-tab">
                <div class="dora-content">
                    <div class="dora-table-card">
                        <div class="dora-card-header">
                            <h2>DORA Metrics Overview</h2>
                            <p>Assess each metric against industry benchmark tiers to understand your current delivery capability.</p>
                        </div>
                        <div class="dora-table">
                            <div class="dora-table-header"></div>
                            <div class="dora-table-header">Low</div>
                            <div class="dora-table-header">Medium</div>
                            <div class="dora-table-header">High</div>
                            <div class="dora-table-header">Elite</div>

                            <div class="dora-metric" data-metric="deployment_frequency">Deployment Frequency</div>
                            <button type="button" class="dora-cell" data-metric="deployment_frequency" data-tier="low">Fewer than once per month</button>
                            <button type="button" class="dora-cell" data-metric="deployment_frequency" data-tier="medium">1 per week – 1 per month</button>
                            <button type="button" class="dora-cell" data-metric="deployment_frequency" data-tier="high">1 per day – 1 per week</button>
                            <button type="button" class="dora-cell" data-metric="deployment_frequency" data-tier="elite">On-demand, multiple per day</button>

                            <div class="dora-metric" data-metric="commit_frequency">Commit Frequency</div>
                            <button type="button" class="dora-cell" data-metric="commit_frequency" data-tier="low">&lt; 5 commits per developer per week</button>
                            <button type="button" class="dora-cell" data-metric="commit_frequency" data-tier="medium">5 – 15 commits per developer per week</button>
                            <button type="button" class="dora-cell" data-metric="commit_frequency" data-tier="high">15 – 30 commits per developer per week</button>
                            <button type="button" class="dora-cell" data-metric="commit_frequency" data-tier="elite">&gt; 30 commits per developer per week</button>

                            <div class="dora-metric" data-metric="lead_time">Lead Time for Changes</div>
                            <button type="button" class="dora-cell" data-metric="lead_time" data-tier="low">&gt; 1 month</button>
                            <button type="button" class="dora-cell" data-metric="lead_time" data-tier="medium">1 week – 1 month</button>
                            <button type="button" class="dora-cell" data-metric="lead_time" data-tier="high">1 day – 1 week</button>
                            <button type="button" class="dora-cell" data-metric="lead_time" data-tier="elite">&lt; 1 day</button>

                            <div class="dora-metric" data-metric="branch_lifetime">Branch Lifetime</div>
                            <button type="button" class="dora-cell" data-metric="branch_lifetime" data-tier="low">More than 2 weeks open</button>
                            <button type="button" class="dora-cell" data-metric="branch_lifetime" data-tier="medium">~3 – 10 days open</button>
                            <button type="button" class="dora-cell" data-metric="branch_lifetime" data-tier="high">~1 – 3 days open</button>
                            <button type="button" class="dora-cell" data-metric="branch_lifetime" data-tier="elite">≤ 1 day open</button>

                            <div class="dora-metric" data-metric="change_failure">Change Failure Rate</div>
                            <button type="button" class="dora-cell" data-metric="change_failure" data-tier="low">&gt; 45%</button>
                            <button type="button" class="dora-cell" data-metric="change_failure" data-tier="medium">31% – 45%</button>
                            <button type="button" class="dora-cell" data-metric="change_failure" data-tier="high">15% – 30%</button>
                            <button type="button" class="dora-cell" data-metric="change_failure" data-tier="elite">&lt; 15%</button>

                            <div class="dora-metric" data-metric="mttr">MTTR (Restore Service)</div>
                            <button type="button" class="dora-cell" data-metric="mttr" data-tier="low">&gt; 1 week</button>
                            <button type="button" class="dora-cell" data-metric="mttr" data-tier="medium">1 day – 1 week</button>
                            <button type="button" class="dora-cell" data-metric="mttr" data-tier="high">1 – 24 hours</button>
                            <button type="button" class="dora-cell" data-metric="mttr" data-tier="elite">&lt; 1 hour</button>
                        </div>
                        <div class="dora-input">
                            <label for="pbis-per-sprint">PBIs per Sprint per Team</label>
                            <input type="number" id="pbis-per-sprint" name="pbis_per_sprint" min="0" step="0.1" placeholder="Enter average PBIs completed">
                            <span class="dora-input-hint">Average number of Product Backlog Items completed by a team each sprint.</span>
                        </div>
                    </div>
                    <div class="westrum-card">
                        <div class="westrum-card-header">
                            <div>
                                <h3>Westrum Organizational Culture</h3>
                                <p>Where does your team sit on the Westrum spectrum from Pathological to Generative?</p>
                            </div>
                            <div class="westrum-label-pill" id="westrum-scale-label">Calculative (4)</div>
                        </div>
                        <div class="westrum-slider-wrap" aria-hidden="true">
                            <input type="range" id="westrum-scale" min="1" max="7" step="0.1" value="4">
                        </div>
                        <div class="westrum-scale-steps" id="westrum-scale-steps" role="group" aria-label="Westrum scale">
                            <button type="button" class="westrum-step" data-value="1">
                                <span class="westrum-step-index">1</span>
                                <span class="westrum-step-text">Pathological</span>
                            </button>
                            <button type="button" class="westrum-step" data-value="2">
                                <span class="westrum-step-index">2</span>
                                <span class="westrum-step-text">Power-Oriented</span>
                            </button>
                            <button type="button" class="westrum-step" data-value="3">
                                <span class="westrum-step-index">3</span>
                                <span class="westrum-step-text">Rule-Oriented</span>
                            </button>
                            <button type="button" class="westrum-step" data-value="4">
                                <span class="westrum-step-index">4</span>
                                <span class="westrum-step-text">Calculative</span>
                            </button>
                            <button type="button" class="westrum-step" data-value="5">
                                <span class="westrum-step-index">5</span>
                                <span class="westrum-step-text">Collaborative</span>
                            </button>
                            <button type="button" class="westrum-step" data-value="6">
                                <span class="westrum-step-index">6</span>
                                <span class="westrum-step-text">Learning-Oriented</span>
                            </button>
                            <button type="button" class="westrum-step" data-value="7">
                                <span class="westrum-step-index">7</span>
                                <span class="westrum-step-text">Generative</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="edit-tab-content" id="time-tab">
                <div class="time-content">
                    <div class="time-card">
                        <div class="time-card-header">
                            <div>
                                <h2>Team Time Allocation</h2>
                                <p>Distribute your available capacity across the focus areas your team invests in each sprint.</p>
                            </div>
                            <div class="time-allocation-summary" id="time-allocation-summary">Remaining capacity: 100%</div>
                        </div>
                        <div class="time-progress">
                            <div class="time-progress-bar" id="time-allocation-progress"></div>
                        </div>
                        <div class="time-grid">
                            <div class="time-item" data-time-item="meetings">
                                <span class="time-lock-badge" aria-hidden="true">
                                    <span class="material-icons" aria-hidden="true">check_circle</span>
                                    Locked
                                </span>
                                <div class="time-lock">
                                    <label>
                                        <input type="checkbox" data-time-lock="meetings">
                                        Locked
                                    </label>
                                </div>
                                <label for="time-meetings">Meetings</label>
                                <span class="time-item-hint">Planning ceremonies, team syncs, reviews, retrospectives.</span>
                                <div class="time-slider">
                                    <input type="range" min="0" max="100" step="1" value="20" data-time-slider="meetings">
                                </div>
                                <div class="time-input-group">
                                    <input type="number" id="time-meetings" data-time-category="meetings" min="0" max="100" step="1" value="20">
                                    <span class="time-input-suffix">%</span>
                                </div>
                            </div>
                            <div class="time-item" data-time-item="unplanned">
                                <span class="time-lock-badge" aria-hidden="true">
                                    <span class="material-icons" aria-hidden="true">check_circle</span>
                                    Locked
                                </span>
                                <div class="time-lock">
                                    <label>
                                        <input type="checkbox" data-time-lock="unplanned">
                                        Locked
                                    </label>
                                </div>
                                <label for="time-unplanned">Unplanned / Interruptions</label>
                                <span class="time-item-hint">Production incidents, urgent escalations, unplanned requests.</span>
                                <div class="time-slider">
                                    <input type="range" min="0" max="100" step="1" value="15" data-time-slider="unplanned">
                                </div>
                                <div class="time-input-group">
                                    <input type="number" id="time-unplanned" data-time-category="unplanned" min="0" max="100" step="1" value="15">
                                    <span class="time-input-suffix">%</span>
                                </div>
                            </div>
                            <div class="time-item" data-time-item="bugs">
                                <span class="time-lock-badge" aria-hidden="true">
                                    <span class="material-icons" aria-hidden="true">check_circle</span>
                                    Locked
                                </span>
                                <div class="time-lock">
                                    <label>
                                        <input type="checkbox" data-time-lock="bugs">
                                        Locked
                                    </label>
                                </div>
                                <label for="time-bugs">Bug Fixing</label>
                                <span class="time-item-hint">Stabilising releases, defect triage, remediation.</span>
                                <div class="time-slider">
                                    <input type="range" min="0" max="100" step="1" value="15" data-time-slider="bugs">
                                </div>
                                <div class="time-input-group">
                                    <input type="number" id="time-bugs" data-time-category="bugs" min="0" max="100" step="1" value="15">
                                    <span class="time-input-suffix">%</span>
                                </div>
                            </div>
                            <div class="time-item" data-time-item="tech_debt">
                                <span class="time-lock-badge" aria-hidden="true">
                                    <span class="material-icons" aria-hidden="true">check_circle</span>
                                    Locked
                                </span>
                                <div class="time-lock">
                                    <label>
                                        <input type="checkbox" data-time-lock="tech_debt">
                                        Locked
                                    </label>
                                </div>
                                <label for="time-tech-debt">Software Quality Investment</label>
                                <span class="time-item-hint">Improving software quality so product &amp; process outcomes stay healthy.</span>
                                <div class="time-slider">
                                    <input type="range" min="0" max="100" step="1" value="20" data-time-slider="tech_debt">
                                </div>
                                <div class="time-input-group">
                                    <input type="number" id="time-tech-debt" data-time-category="tech_debt" min="0" max="100" step="1" value="20">
                                    <span class="time-input-suffix">%</span>
                                </div>
                            </div>
                            <div class="time-item" data-time-item="features">
                                <span class="time-lock-badge" aria-hidden="true">
                                    <span class="material-icons" aria-hidden="true">check_circle</span>
                                    Locked
                                </span>
                                <div class="time-lock">
                                    <label>
                                        <input type="checkbox" data-time-lock="features">
                                        Locked
                                    </label>
                                </div>
                                <label for="time-features">Feature Development</label>
                                <span class="time-item-hint">Net-new product work, enhancements, discovery experiments.</span>
                                <div class="time-slider">
                                    <input type="range" min="0" max="100" step="1" value="30" data-time-slider="features">
                                </div>
                                <div class="time-input-group">
                                    <input type="number" id="time-features" data-time-category="features" min="0" max="100" step="1" value="30">
                                    <span class="time-input-suffix">%</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="time-card">
                        <div class="time-card-header">
                            <div>
                                <h2>Quality Definitions</h2>
                                <p>Use shared language when debating trade-offs. Balance quality so product value, delivery flow, and software health reinforce each other.</p>
                            </div>
                        </div>
                        <div class="quality-grid">
                            <div class="quality-pill">
                                <h4>Product Quality</h4>
                                <p>Customer experience and outcomes&mdash;metrics like NPS, adoption, and retention.</p>
                            </div>
                            <div class="quality-pill">
                                <h4>Process Quality</h4>
                                <p>Ability to sustain predictable flow while meeting the prescribed product quality.</p>
                            </div>
                            <div class="quality-pill">
                                <h4>Software Quality</h4>
                                <p>Technical integrity of the codebase&mdash;the grade you would give a CS thesis.</p>
                            </div>
                        </div>
                        <div class="quality-grid">
                            <div class="quality-note">
                                <strong>Tech Debt</strong>
                                <p>Insufficient software quality causing product or process quality to suffer.</p>
                            </div>
                            <div class="quality-note">
                                <strong>Gold Plating</strong>
                                <p>Software quality work that does not materially improve product or process quality.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="edit-tab-content" id="analysis-tab">
                <div class="analysis-content">
                    <div class="analysis-card">
                        <div class="analysis-card-header">
                            <div>
                                <h2>Systems Analysis</h2>
                                <p>Combine your CRT, delivery metrics, and culture signals to surface systemic constraints.</p>
                            </div>
                            <div class="analysis-status" id="analysis-status">Provide CRT text, DORA selections, Westrum score, and lock all time categories.</div>
                        </div>
                        <div class="analysis-actions">
                            <button type="button" id="analysis-refresh-button" disabled>
                                <span class="material-icons" aria-hidden="true">play_arrow</span>
                                Run Analysis
                            </button>
                        </div>
                        <div class="analysis-meta" id="analysis-meta"></div>
                        <div class="analysis-output" id="analysis-output">
                            <p>Enter CRT content, select DORA tiers, set the Westrum slider, and lock every time category to enable analysis.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="visualization-container">
            <svg width="100%" height="100%"></svg>
            <div class="controls">
                <input type="text" id="search-box" placeholder="Search nodes...">
                <div class="node-list"></div>
            </div>
            <div class="branch-panel" id="branch-panel">
                <div id="branch-content">
                    <!-- Branch path will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import init, { parse_content } from './pkg/crt_to_cypher.js';

        function sanitizeBaseUrl(url) {
            if (!url) return null;
            return url.endsWith('/') ? url.slice(0, -1) : url;
        }

        function resolveBackendBaseUrl() {
            const stored = sanitizeBaseUrl(localStorage.getItem('crtBackendUrl'));
            if (stored) return stored;

            const globalOverride = sanitizeBaseUrl(window.CRT_BACKEND_URL);
            if (globalOverride) return globalOverride;

            const { protocol, hostname, port } = window.location;
            const defaultPort = '8080';

            if (protocol === 'file:') {
                return `http://localhost:${defaultPort}`;
            }

            if (protocol === 'http:' || protocol === 'https:') {
                if (port) {
                    return `${protocol}//${hostname}:${port}`;
                }
                return `${protocol}//${hostname}:${defaultPort}`;
            }

            return `http://localhost:${defaultPort}`;
        }

        let backendBaseUrl = resolveBackendBaseUrl();

        window.setBackendBaseUrl = function(url) {
            const cleaned = sanitizeBaseUrl(url);
            if (cleaned) {
                localStorage.setItem('crtBackendUrl', cleaned);
                backendBaseUrl = cleaned;
                console.info('CRT backend URL set to', backendBaseUrl);
            } else {
                localStorage.removeItem('crtBackendUrl');
                backendBaseUrl = resolveBackendBaseUrl();
                console.info('CRT backend URL reset to', backendBaseUrl);
            }
        };

        function updateLineNumbers() {
            const textarea = document.getElementById('input');
            const lineNumbers = document.getElementById('line-numbers');
            const lines = textarea.value.split('\n').length;
            lineNumbers.innerHTML = Array.from({length: lines}, (_, i) => i + 1).join('\n');
            lineNumbers.scrollTop = textarea.scrollTop;
            scheduleViewToggleValidation();
        }

        window.onerror = function(message, source, lineno, colno, error) {
            console.error('Error caught:', message, 'at', source, lineno, colno);
            return true;
        };

        let isVisualizationMode = false;
        let wasmReady = false;
        let viewToggleIsEnabled = false;
        let viewToggleValidationTimer = null;
        let viewToggleIntended = false;
        let activeEditTab = 'crt';
        let lastRefinedContent = null;
        let isRefining = false;
        let refineButtonIntendedDisabled = false;
        function setViewToggleEnabled(enabled) {
            const button = document.getElementById('view-toggle-button');
            viewToggleIntended = Boolean(enabled);
            const effective = viewToggleIntended && activeEditTab === 'crt';
            viewToggleIsEnabled = effective;
            if (button) {
                button.disabled = !effective;
                button.classList.toggle('disabled', !effective);
            }
        }

        function scheduleViewToggleValidation() {
            if (viewToggleValidationTimer) {
                clearTimeout(viewToggleValidationTimer);
            }
            viewToggleValidationTimer = setTimeout(updateViewToggleState, 200);
        }

        function updateViewToggleState() {
            viewToggleValidationTimer = null;
            if (!wasmReady || activeEditTab !== 'crt') {
                return;
            }
            const content = document.getElementById('input').value;
            try {
                parse_content(content);
                setViewToggleEnabled(true);
            } catch (error) {
                setViewToggleEnabled(false);
            }
        }

        setViewToggleEnabled(false);

        function exitVisualizationMode() {
            const mainContent = document.querySelector('.main-content');
            const icon = document.getElementById('view-toggle-icon');
            mainContent.classList.remove('show-visualization');
            icon.textContent = 'account_tree';
            isVisualizationMode = false;
        }

        window.toggleView = function() {
            if (!isVisualizationMode && !viewToggleIsEnabled) {
                return;
            }
            const mainContent = document.querySelector('.main-content');
            const icon = document.getElementById('view-toggle-icon');
            isVisualizationMode = !isVisualizationMode;
            
            if (isVisualizationMode) {
                // Save content before switching to visualization
                saveToLocalStorage();
                window.closeRefineView?.();
                
                mainContent.classList.add('show-visualization');
                icon.textContent = 'edit';
                updateVisualization();
            } else {
                exitVisualizationMode();
            }
        };

        function updateVisualization() {
            const input = document.getElementById('input').value;
            try {
                const result = parse_content(input);
                setViewToggleEnabled(true);
                renderGraph(result.nodes, result.links);
            } catch (error) {
                console.error('Error parsing content:', error);
                setViewToggleEnabled(false);
                if (isVisualizationMode) {
                    exitVisualizationMode();
                }
            }
        }

        function applyActiveEditTab() {
            document.querySelectorAll('.edit-tab-button').forEach((button) => {
                const target = button.dataset.editTab;
                const isActive = target === activeEditTab;
                button.classList.toggle('active', isActive);
            });
            document.querySelectorAll('.edit-tab-content').forEach((section) => {
                const isActive = section.id === `${activeEditTab}-tab` || (activeEditTab === 'crt' && section.id === 'crt-tab');
                section.classList.toggle('active', isActive);
            });
            const mainContent = document.querySelector('.main-content');
            if (mainContent) {
                mainContent.classList.toggle('crt-active', activeEditTab === 'crt');
            }
            if (activeEditTab !== 'crt') {
                if (isVisualizationMode) {
                    exitVisualizationMode();
                }
                window.closeRefineView?.();
            } else {
                scheduleViewToggleValidation();
            }
            setRefineButtonState(refineButtonIntendedDisabled);
            setViewToggleEnabled(viewToggleIntended);
            if (activeEditTab === 'dora') {
                updateWestrumScaleLabel();
            } else if (activeEditTab === 'time') {
                updateTimeAllocationSummary();
            } else if (activeEditTab === 'analysis') {
                updateAnalysisAvailability();
                runAnalysis();
            }
            const menuButton = document.getElementById('menu-button');
            if (menuButton) {
                menuButton.disabled = activeEditTab !== 'crt';
                menuButton.classList.toggle('disabled', activeEditTab !== 'crt');
            }
            if (activeEditTab !== 'crt') {
                closeSidebar();
            }
        }

        function setActiveEditTab(tab) {
            const allowed = new Set(['crt', 'dora', 'time', 'analysis']);
            if (tab === 'analysis' && !isAnalysisReady()) {
                return;
            }
            const nextTab = allowed.has(tab) ? tab : 'crt';
            if (nextTab === activeEditTab) {
                return;
            }
            activeEditTab = nextTab;
            applyActiveEditTab();
        }

        const WESTRUM_LEVELS = {
            1: 'Pathological',
            2: 'Power-Oriented',
            3: 'Rule-Oriented',
            4: 'Calculative',
            5: 'Collaborative',
            6: 'Learning-Oriented',
            7: 'Generative',
        };

        function updateWestrumScaleLabel() {
            const slider = document.getElementById('westrum-scale');
            const label = document.getElementById('westrum-scale-label');
            if (!slider || !label) return;
            const rawValue = Number(slider.value) || 1;
            const min = Number(slider.min) || 1;
            const max = Number(slider.max) || 7;
            const range = Math.max(max - min, 1);
            const nearest = Math.min(max, Math.max(min, Math.round(rawValue)));
            const descriptor = WESTRUM_LEVELS[nearest] ?? 'Unknown';
            label.textContent = `${descriptor} (${rawValue.toFixed(1)})`;
            slider.setAttribute('aria-valuetext', `${descriptor} (${rawValue.toFixed(1)})`);
            const percent = ((rawValue - min) / range) * 100;
            slider.style.background = `linear-gradient(90deg, var(--accent-color) ${percent}%, rgba(255, 255, 255, 0.08) ${percent}%)`;
            document.querySelectorAll('.westrum-step').forEach((step) => {
                const match = Number(step.dataset.value) === nearest;
                step.classList.toggle('active', match);
                step.setAttribute('aria-pressed', match ? 'true' : 'false');
            });
        }

        function clampPercentage(value) {
            if (Number.isNaN(value)) return 0;
            return Math.max(0, Math.min(100, Math.round(value)));
        }

function syncTimeSlider(category, value) {
            const slider = document.querySelector(`[data-time-slider=\"${category}\"]`);
            if (slider) {
                slider.value = value;
            }
        }

function setLockState(category, locked = true) {
            const lock = document.querySelector(`[data-time-lock=\"${category}\"]`);
            const card = document.querySelector(`[data-time-item=\"${category}\"]`);
            const isLocked = Boolean(locked);
            if (lock) {
                lock.checked = isLocked;
            }
            if (card) {
                card.classList.toggle('locked', isLocked);
            }
        }

        function setCategoryValue(category, value) {
            const numeric = clampPercentage(Math.round(value));
            const input = document.querySelector(`[data-time-category=\"${category}\"]`);
            const slider = document.querySelector(`[data-time-slider=\"${category}\"]`);
            if (input) {
                input.value = numeric;
            }
            if (slider) {
                slider.value = numeric;
            }
        }

        function updateSliderVisuals() {
            document.querySelectorAll('[data-time-slider]').forEach((slider) => {
                const numeric = clampPercentage(Number(slider.value));
                slider.style.background = `linear-gradient(90deg, var(--accent-color) ${numeric}%, rgba(255, 255, 255, 0.08) ${numeric}%)`;
            });
        }

        function distributeUnlocked() {
            const unlocked = [];
            let totalLocked = 0;
            TIME_CATEGORIES.forEach((category) => {
                const input = document.querySelector(`[data-time-category="${category}"]`);
                if (!input) {
                    return;
                }
                const value = clampPercentage(Number(input.value));
                const lock = document.querySelector(`[data-time-lock="${category}"]`);
                const isLocked = lock && lock.checked;
                if (isLocked) {
                    totalLocked += value;
                } else {
                    unlocked.push({ category });
                }
            });
            if (!unlocked.length) {
                updateSliderVisuals();
                return;
            }
            let remaining = Math.round(100 - totalLocked);
            if (remaining <= 0) {
                unlocked.forEach(({ category }) => setCategoryValue(category, 0));
                updateSliderVisuals();
                return;
            }
            const base = Math.floor(remaining / unlocked.length);
            let remainder = remaining - base * unlocked.length;
            unlocked.forEach(({ category }) => {
                let value = base;
                if (remainder > 0) {
                    value += 1;
                    remainder -= 1;
                }
                setCategoryValue(category, value);
            });
            updateSliderVisuals();
        }

        function applyManualTimeAllocation(category, value) {
            const numeric = clampPercentage(Number(value));
            setCategoryValue(category, numeric);
            setLockState(category, true);
            distributeUnlocked();
            markAnalysisStale();
            updateTimeAllocationSummary();
        }

        function updateTimeAllocationSummary() {
            const inputs = document.querySelectorAll('[data-time-category]');
            let total = 0;
            inputs.forEach((input) => {
                const numeric = clampPercentage(Number(input.value));
                if (numeric !== Number(input.value)) {
                    input.value = numeric;
                }
                total += numeric;
                syncTimeSlider(input.dataset.timeCategory, numeric);
            });
            const summary = document.getElementById('time-allocation-summary');
            const progress = document.getElementById('time-allocation-progress');
            if (progress) {
                const clamped = Math.max(0, Math.min(total, 100));
                progress.style.width = `${clamped}%`;
                progress.classList.toggle('overallocated', total > 100);
            }
            if (!summary) return;
            const remaining = 100 - total;
            summary.classList.remove('error', 'good');
            if (total === 100) {
                summary.textContent = 'Perfect allocation: 100% assigned.';
                summary.classList.add('good');
            } else if (total < 100) {
                summary.textContent = `Remaining capacity: ${Math.max(0, Math.round(remaining))}%`;
                summary.classList.add('good');
            } else {
                summary.textContent = `Over-allocated by ${Math.round(Math.abs(remaining))}%`;
                summary.classList.add('error');
            }
            updateSliderVisuals();
            updateAnalysisAvailability();
        }

        function getTimeAllocationData() {
            const categories = {};
            let total = 0;
            let lockedCount = 0;
            TIME_CATEGORIES.forEach((category) => {
                const input = document.querySelector(`[data-time-category="${category}"]`);
                const lock = document.querySelector(`[data-time-lock="${category}"]`);
                const value = clampPercentage(Number(input?.value ?? 0));
                const locked = Boolean(lock && lock.checked);
                categories[category] = { value, locked };
                total += value;
                if (locked) {
                    lockedCount += 1;
                }
            });
            return {
                categories,
                total,
                lockedCount,
                allLocked: lockedCount === TIME_CATEGORIES.length,
            };
        }

        function isTimeFullyLocked() {
            const data = getTimeAllocationData();
            return data.allLocked && Math.abs(data.total - 100) <= 1;
        }

        function getWestrumData() {
            const slider = document.getElementById('westrum-scale');
            if (!slider) return null;
            const raw = Number(slider.value);
            const score = Number.isFinite(raw) ? raw : null;
            const rounded = score !== null ? Math.round(score) : null;
            return {
                score,
                rounded,
                descriptor: rounded !== null ? (WESTRUM_LEVELS[rounded] ?? 'Unknown') : null,
            };
        }

        function isDoraComplete() {
            return DORA_CORE_METRICS.every((metric) => {
                const value = doraSelections[metric];
                return typeof value === 'string' && value.length > 0;
            });
        }

        function hasCrtContent() {
            const textarea = document.getElementById('input');
            return Boolean(textarea && textarea.value.trim().length > 0);
        }

        function isWestrumProvided() {
            const data = getWestrumData();
            return data !== null && Number.isFinite(data.score);
        }

        function isAnalysisReady() {
            return hasCrtContent() && isDoraComplete() && isTimeFullyLocked() && isWestrumProvided();
        }

        function setAnalysisStatus(state, message) {
            const statusEl = document.getElementById('analysis-status');
            if (!statusEl) return;
            statusEl.classList.remove('running', 'error', 'warning');
            if (state === 'running') {
                statusEl.classList.add('running');
            } else if (state === 'error') {
                statusEl.classList.add('error');
            } else if (state === 'warning') {
                statusEl.classList.add('warning');
            }
            statusEl.textContent = message;
        }

        function markAnalysisStale() {
            analysisNeedsRefresh = true;
            if (isRunningAnalysis) {
                return;
            }
            if (isAnalysisReady()) {
                setAnalysisStatus('warning', 'Inputs changed. Re-run the analysis.');
            } else {
                setAnalysisStatus(
                    'idle',
                    'Provide CRT text, DORA selections, Westrum score, and lock all time categories.'
                );
            }
        }

        function updateAnalysisAvailability() {
            const ready = isAnalysisReady();
            const tabButton = document.getElementById('analysis-tab-button');
            const runButton = document.getElementById('analysis-refresh-button');
            if (tabButton) {
                tabButton.disabled = !ready;
                tabButton.classList.toggle('disabled', !ready);
                tabButton.title = ready
                    ? 'Generate a systems analysis from your inputs.'
                    : 'Provide CRT, DORA, Westrum, and locked time allocation data to enable analysis.';
            }
            if (runButton) {
                runButton.disabled = !ready || isRunningAnalysis;
            }
            if (!ready) {
                if (activeEditTab === 'analysis') {
                    setActiveEditTab('crt');
                    return;
                }
                if (!isRunningAnalysis) {
                    setAnalysisStatus(
                        'idle',
                        'Provide CRT text, DORA selections, Westrum score, and lock all time categories.'
                    );
                    const output = document.getElementById('analysis-output');
                    if (output) {
                        output.innerHTML = renderAnalysisMessage(
                            'Enter CRT content, select DORA tiers, set the Westrum slider, and lock every time category to enable analysis.'
                        );
                    }
                    const meta = document.getElementById('analysis-meta');
                    if (meta) {
                        meta.textContent = '';
                    }
                }
            } else if (!isRunningAnalysis) {
                if (analysisNeedsRefresh) {
                    setAnalysisStatus('warning', 'Inputs changed. Re-run the analysis.');
                } else {
                    setAnalysisStatus('idle', 'Analysis is up to date.');
                }
            }
        }

        function toDoraCategoryName(value) {
            if (!value) return null;
            const normalised = String(value).trim().toLowerCase();
            switch (normalised) {
                case 'low':
                    return 'Low';
                case 'medium':
                    return 'Medium';
                case 'high':
                    return 'High';
                case 'elite':
                    return 'Elite';
                default:
                    return null;
            }
        }

        function toIntPercentage(value) {
            const numeric = Number(value);
            if (!Number.isFinite(numeric)) {
                return 0;
            }
            return Math.round(numeric);
        }

        function buildAnalysisPayload() {
            const crtField = document.getElementById('input');
            const crt = crtField ? crtField.value : '';

            const mttrCategory = toDoraCategoryName(doraSelections.mttr) ?? 'Medium';

            const westrum = getWestrumData();
            const westrumScore = westrum && Number.isFinite(westrum.score)
                ? Number(westrum.score)
                : null;

            const time = getTimeAllocationData();
            const timePayload = {
                meetings: toIntPercentage(time.categories.meetings?.value),
                unplanned: toIntPercentage(time.categories.unplanned?.value),
                bugs: toIntPercentage(time.categories.bugs?.value),
                feature: toIntPercentage(time.categories.features?.value),
                tech_debt: toIntPercentage(time.categories.tech_debt?.value),
            };

            const commitFrequency = toDoraCategoryName(doraSelections.commit_frequency) ?? 'Medium';
            const branchLifetime = toDoraCategoryName(doraSelections.branch_lifetime) ?? 'Medium';
            const selections = window.getDoraSelections();
            const pbisValue =
                selections.pbis_per_sprint_per_team !== null &&
                Number.isFinite(selections.pbis_per_sprint_per_team)
                    ? Number(selections.pbis_per_sprint_per_team)
                    : 0;

            const payload = {
                crt,
                dora_metrics: {
                    mttr: mttrCategory,
                },
                extended_engineering_metrics: {
                    commit_frequency: commitFrequency,
                    branch_lifetime: branchLifetime,
                    pbis_delivered_per_sprint_per_team: pbisValue,
                },
                time_allocation: timePayload,
            };

            if (westrumScore !== null) {
                payload.westrum = westrumScore;
            }

            return payload;
        }

        function renderAnalysisResult(data) {
            const output = document.getElementById('analysis-output');
            const meta = document.getElementById('analysis-meta');
            if (!output || !meta) return { hasWarnings: false };

            const analyser = data || {};

            if (analyser.result !== undefined) {
                output.innerHTML = buildAnalysisContent(analyser.result);
            } else {
                output.innerHTML = renderAnalysisMessage('No analysis output was returned.');
            }

            lastAnalysisResult = data;
            return { hasWarnings: false };
        }

        function renderAnalysisMessage(message) {
            return `<p>${escapeHtml(String(message))}</p>`;
        }

        function normalizeAnalysisMessages(value) {
            if (value === null || value === undefined) {
                return [];
            }
            if (Array.isArray(value)) {
                return value
                    .filter((item) => item !== null && item !== undefined)
                    .map((item) => (typeof item === 'string' ? item : JSON.stringify(item)));
            }
            if (typeof value === 'string') {
                return [value];
            }
            return [JSON.stringify(value)];
        }

        function buildAnalysisContent(result) {
            if (result === null || result === undefined) {
                return renderAnalysisMessage('No analysis output was returned.');
            }
            if (isSimpleAnalysisValue(result)) {
                return renderAnalysisMessage(result);
            }
            if (Array.isArray(result)) {
                const listContent = renderAnalysisArray(result, 0);
                return `<div class="analysis-section">${listContent}</div>`;
            }
            if (typeof result === 'object') {
                const sections = Object.keys(result).map((key) => renderTopLevelAnalysisSection(key, result[key]));
                return sections.join('') || renderAnalysisMessage('No analysis output was returned.');
            }
            return renderAnalysisMessage(result);
        }

        function renderTopLevelAnalysisSection(key, value) {
            if (isSimpleAnalysisValue(value)) {
                return `<div class="analysis-section"><p class="analysis-section-title"><strong>${escapeHtml(
                    key
                )}:</strong> ${escapeHtml(String(value))}</p></div>`;
            }
            const body = renderAnalysisValue(value, 0);
            return `<div class="analysis-section"><p class="analysis-section-title">${escapeHtml(
                key
            )}</p>${body}</div>`;
        }

        function renderAnalysisValue(value, depth) {
            if (value === null || value === undefined) {
                return `<p class="analysis-empty">No data provided.</p>`;
            }
            if (isSimpleAnalysisValue(value)) {
                return `<p>${escapeHtml(String(value))}</p>`;
            }
            if (Array.isArray(value)) {
                return renderAnalysisArray(value, depth + 1);
            }
            if (typeof value === 'object') {
                const entries = Object.entries(value)
                    .map(
                        ([childKey, childValue]) =>
                            `<div class="analysis-subsection"><p class="analysis-key">${escapeHtml(
                                childKey
                            )}:</p>${renderAnalysisValue(childValue, depth + 1)}</div>`
                    )
                    .join('');
                return entries || `<p class="analysis-empty">No details available.</p>`;
            }
            return `<p>${escapeHtml(String(value))}</p>`;
        }

        function renderAnalysisArray(items, depth) {
            if (!items.length) {
                return '<ul><li class="analysis-empty">No items.</li></ul>';
            }
            const rendered = items
                .map((item) => `<li>${renderAnalysisListItem(item, depth + 1)}</li>`)
                .join('');
            return `<ul>${rendered}</ul>`;
        }

        function renderAnalysisListItem(item, depth) {
            if (item === null || item === undefined) {
                return '<span class="analysis-empty">—</span>';
            }
            if (isSimpleAnalysisValue(item)) {
                return escapeHtml(String(item));
            }
            if (Array.isArray(item)) {
                return renderAnalysisValue(item, depth + 1);
            }
            if (typeof item === 'object') {
                const labelParts = [];
                if (Object.prototype.hasOwnProperty.call(item, 'id') && item.id) {
                    labelParts.push(`<strong>${escapeHtml(String(item.id))}</strong>`);
                }
                if (Object.prototype.hasOwnProperty.call(item, 'text') && item.text) {
                    labelParts.push(escapeHtml(String(item.text)));
                }
                const headline = labelParts.join(' — ');
                const remainder = Object.entries(item)
                    .filter(([key]) => key !== 'id' && key !== 'text')
                    .map(
                        ([key, value]) =>
                            `<div class="analysis-subdetail"><strong>${escapeHtml(key)}:</strong> ${renderAnalysisInlineValue(
                                value,
                                depth + 1
                            )}</div>`
                    )
                    .join('');
                if (headline && remainder) {
                    return `${headline}<div class="analysis-subdetails">${remainder}</div>`;
                }
                if (headline) {
                    return headline;
                }
                return remainder || escapeHtml(JSON.stringify(item));
            }
            return escapeHtml(String(item));
        }

        function renderAnalysisInlineValue(value, depth) {
            if (value === null || value === undefined) {
                return '<span class="analysis-empty">—</span>';
            }
            if (isSimpleAnalysisValue(value)) {
                return escapeHtml(String(value));
            }
            return renderAnalysisValue(value, depth);
        }

        function isSimpleAnalysisValue(value) {
            return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';
        }

        function escapeHtml(raw) {
            return String(raw)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        async function runAnalysis(force = false) {
            if (!isAnalysisReady()) {
                return;
            }
            if (isRunningAnalysis) {
                if (!force) {
                    return;
                }
            } else if (!analysisNeedsRefresh && !force) {
                return;
            }
            const runButton = document.getElementById('analysis-refresh-button');
            isRunningAnalysis = true;
            analysisNeedsRefresh = false;
            setAnalysisStatus('running', 'Running analysis...');
            if (runButton) {
                runButton.disabled = true;
            }
            try {
                const payload = buildAnalysisPayload();
                const response = await fetch(`${backendBaseUrl}/api/analyse`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(text || response.statusText);
                }
                const data = await response.json();
                console.log("analysis result", data);
                const { hasWarnings } = renderAnalysisResult(data);
                if (hasWarnings) {
                    setAnalysisStatus('warning', 'Analysis complete with normaliser alerts.');
                } else {
                    setAnalysisStatus('idle', 'Analysis is up to date.');
                }
                analysisNeedsRefresh = false;
            } catch (error) {
                console.error('Analysis request failed', error);
                const output = document.getElementById('analysis-output');
                if (output) {
                    output.innerHTML = renderAnalysisMessage(`Analysis failed: ${error.message || error}`);
                }
                setAnalysisStatus('error', 'Analysis failed. See console for details.');
                analysisNeedsRefresh = true;
            } finally {
                isRunningAnalysis = false;
                if (runButton) {
                    runButton.disabled = !isAnalysisReady();
                }
                updateAnalysisAvailability();
            }
        }

        function initializeDoraTable() {
            const groups = new Map();
            document.querySelectorAll('.dora-cell').forEach((cell) => {
                const metric = cell.dataset.metric;
                const tier = cell.dataset.tier;
                if (!metric || !tier) {
                    return;
                }
                if (!groups.has(metric)) {
                    groups.set(metric, []);
                }
                cell.classList.remove('active');
                groups.get(metric).push(cell);
                cell.addEventListener('click', () => {
                    groups.get(metric).forEach((btn) => btn.classList.remove('active'));
                    cell.classList.add('active');
                    doraSelections[metric] = tier;
                    markAnalysisStale();
                    updateAnalysisAvailability();
                });
            });

        }

        function initializeWestrumScale() {
            const slider = document.getElementById('westrum-scale');
            if (!slider) return;
            const steps = document.querySelectorAll('.westrum-step');
            const handleSliderChange = () => {
                updateWestrumScaleLabel();
                markAnalysisStale();
                updateAnalysisAvailability();
            };
            steps.forEach((step) => {
                step.addEventListener('click', () => {
                    slider.value = step.dataset.value;
                    handleSliderChange();
                });
            });
            slider.addEventListener('input', handleSliderChange);
            slider.addEventListener('change', handleSliderChange);
            updateWestrumScaleLabel();
            updateAnalysisAvailability();
        }

        function setRefineButtonState(disabled) {
            const button = document.getElementById('refine-button');
            if (!button) return;
            refineButtonIntendedDisabled = disabled;
            const effective = disabled || activeEditTab !== 'crt';
            button.disabled = effective;
            button.classList.toggle('disabled', effective);
        }

        const TIME_CATEGORIES = ['meetings', 'unplanned', 'bugs', 'tech_debt', 'features'];
        const DORA_CORE_METRICS = ['deployment_frequency', 'lead_time', 'change_failure', 'mttr'];
        const EXTENDED_ENGINEERING_METRICS = ['commit_frequency', 'branch_lifetime'];
        const DORA_ALL_METRICS = [...new Set([...DORA_CORE_METRICS, ...EXTENDED_ENGINEERING_METRICS])];
        let analysisNeedsRefresh = true;
        let isRunningAnalysis = false;
        let lastAnalysisResult = null;
        let lastRefineResult = null;
        let lastRefineOriginal = '';
        let availableRefineEntities = [];
        let availableRefineLinks = [];
        let selectedEntityAdditions = new Set();
        let selectedLinkAdditions = new Set();
        let refineEntityMap = new Map();
        let refineLinkMap = new Map();
        const doraSelections = {};

        function toArray(value) {
            if (Array.isArray(value)) return value;
            if (value && typeof value === 'object') return Object.values(value);
            return [];
        }

        function normalizeEntity(entity) {
            if (!entity) return null;
            const idRaw = entity.id || entity.entity_id || entity.name;
            if (!idRaw) return null;
            const text = entity.text ?? entity.description ?? '';
            const added = entity.added !== undefined ? Boolean(entity.added) : false;
            return {
                ...entity,
                id: String(idRaw),
                text,
                added,
            };
        }

        function normalizeEntities(list) {
            return toArray(list)
                .map(normalizeEntity)
                .filter(Boolean);
        }

        function deriveLineFromLink(link) {
            if (link.line) return link.line;
            if (Array.isArray(link.expressions) && link.expressions.length) {
                return `${link.id || ''}. ${link.expressions.join(' -> ')}`.trim();
            }
            if (link.text) return link.text;
            return String(link.id || '');
        }

        function normalizeLink(link) {
            if (!link) return null;
            const idRaw = link.id || link.link_id || link.name;
            if (!idRaw) return null;
            const entities = toArray(link.entities).map(String);
            const sourceEntities = toArray(link.source_entities).map(String);
            const targetEntities = toArray(link.target_entities).map(String);

            const fromValue = link.from ?? link.source ?? link.source_entity;
            if (fromValue) {
                const val = String(fromValue);
                sourceEntities.push(val);
                entities.push(val);
            }
            const toValue = link.to ?? link.target ?? link.target_entity;
            if (toValue) {
                const val = String(toValue);
                targetEntities.push(val);
                entities.push(val);
            }

            const added = link.added !== undefined ? Boolean(link.added) : false;
            const unique = (arr) => Array.from(new Set(arr.filter(Boolean)));
            return {
                ...link,
                id: String(idRaw),
                line: deriveLineFromLink({ ...link, id: String(idRaw) }),
                entities: unique(entities),
                source_entities: unique(sourceEntities),
                target_entities: unique(targetEntities),
                added,
            };
        }

        function normalizeLinks(list) {
            return toArray(list)
                .map(normalizeLink)
                .filter(Boolean);
        }

        function showRefineView() {
            document.querySelector('.editor-container').classList.add('show-refine');
        }

        function hideRefineView() {
            document.querySelector('.editor-container').classList.remove('show-refine');
        }

        function getCurrentEntityIds(content) {
            const ids = new Set();
            const lines = content.split('\n');
            let inEntities = false;
            for (const raw of lines) {
                const line = raw.trim();
                if (!inEntities) {
                    if (line.toLowerCase() === 'entities') {
                        inEntities = true;
                    }
                    continue;
                }
                if (line.toLowerCase() === 'links') {
                    break;
                }
                if (!line) continue;
                const match = line.match(/^(E\d+)\./i);
                if (match) {
                    ids.add(match[1]);
                }
            }
            return ids;
        }

        function getCurrentLinkIds(content) {
            const ids = new Set();
            const lines = content.split('\n');
            let inLinks = false;
            for (const raw of lines) {
                const line = raw.trim();
                if (!inLinks) {
                    if (line.toLowerCase() === 'links') {
                        inLinks = true;
                    }
                    continue;
                }
                if (!line) continue;
                const match = line.match(/^(L\d+)\./i);
                if (match) {
                    ids.add(match[1]);
                }
            }
            return ids;
        }

        function formatEntityLine(entity) {
            if (!entity || !entity.id || !entity.text) return null;
            return `${entity.id}. ${entity.text}`;
        }

        function ensureSectionIndices(lines) {
            const entitiesIdx = lines.findIndex(line => line.trim().toLowerCase() === 'entities');
            const linksIdx = lines.findIndex(line => line.trim().toLowerCase() === 'links');
            return { entitiesIdx, linksIdx };
        }

        function insertEntities(content, entityIds) {
            if (!entityIds.length) return content;
            const lines = content.split('\n');
            const { entitiesIdx, linksIdx } = ensureSectionIndices(lines);
            if (entitiesIdx === -1 || linksIdx === -1 || linksIdx <= entitiesIdx) {
                alert('Could not locate Entities/Links sections in the CRT.');
                return content;
            }
            const insertionIdx = linksIdx;
            const newLines = [];
            for (const id of entityIds) {
                const entity = refineEntityMap.get(id);
                const line = formatEntityLine(entity);
                if (line) {
                    newLines.push(line);
                }
            }
            if (!newLines.length) return content;

            const hasBlankBeforeLinks = lines[insertionIdx - 1] !== undefined && lines[insertionIdx - 1].trim() === '';
            const insertArray = hasBlankBeforeLinks ? newLines : [...newLines, ''];
            lines.splice(insertionIdx, 0, ...insertArray);
            return lines.join('\n');
        }

        function insertLinks(content, linkIds) {
            if (!linkIds.length) return content;
            const lines = content.split('\n');
            const { entitiesIdx, linksIdx } = ensureSectionIndices(lines);
            if (linksIdx === -1 || linksIdx <= entitiesIdx) {
                alert('Could not locate Links section in the CRT.');
                return content;
            }

            const linkLines = [];
            for (const id of linkIds) {
                const link = refineLinkMap.get(id);
                if (link && link.line) {
                    linkLines.push(link.line);
                }
            }
            if (!linkLines.length) return content;

            let insertionIdx = lines.length;
            while (insertionIdx > linksIdx + 1 && lines[insertionIdx - 1].trim() === '') {
                insertionIdx--;
            }
            lines.splice(insertionIdx, 0, ...linkLines);
            return lines.join('\n');
        }

        function renderRefinePreview(originalText, response) {
            lastRefineOriginal = originalText;
            lastRefineResult = response;
            const currentText = document.getElementById('input').value;
            const currentEntities = getCurrentEntityIds(currentText);
            const currentLinks = getCurrentLinkIds(currentText);

            refineEntityMap = new Map();
            refineLinkMap = new Map();

            const restatement = response?.['CRT Restatement'] || {};
            const allEntities = normalizeEntities(restatement.Entities);
            const allLinks = normalizeLinks(restatement.Links);

            allEntities.forEach(entity => {
                if (entity && entity.id) {
                    refineEntityMap.set(entity.id, entity);
                }
            });
            allLinks.forEach(link => {
                if (link && link.id) {
                    refineLinkMap.set(link.id, link);
                }
            });

            const entityIdPattern = /^E\d+$/;
            const usedEntityIds = new Set(currentEntities);
            availableRefineEntities = allEntities.filter(entity => {
                if (!entity || !entity.id || entity.added !== true) {
                    return false;
                }
                if (!entityIdPattern.test(entity.id)) {
                    console.warn('Skipping invalid entity id from refinement:', entity.id);
                    return false;
                }
                if (usedEntityIds.has(entity.id)) {
                    return false;
                }
                usedEntityIds.add(entity.id);
                return true;
            });

            const knownEntityIds = new Set([...currentEntities, ...availableRefineEntities.map(e => e.id)]);

            availableRefineLinks = allLinks.filter(link => {
                if (!link || !link.id || link.added !== true || currentLinks.has(link.id)) {
                    return false;
                }

                const allEntitiesInLink = new Set([
                    ...(Array.isArray(link.entities) ? link.entities : []),
                    ...(Array.isArray(link.source_entities) ? link.source_entities : []),
                    ...(Array.isArray(link.target_entities) ? link.target_entities : []),
                ]);

                for (const entityId of allEntitiesInLink) {
                    if (entityId && (!entityIdPattern.test(entityId) || !knownEntityIds.has(entityId))) {
                        console.warn('Skipping link due to unknown entity reference:', link.id, entityId);
                        return false;
                    }
                }

                return true;
            });

            selectedEntityAdditions = new Set(availableRefineEntities.map(entity => entity.id));
            selectedLinkAdditions = new Set(availableRefineLinks.map(link => link.id));

            document.getElementById('refine-current-text').textContent = currentText;

            updateRefineSummary();
            renderEntitySuggestions();
            renderLinkSuggestions();
            showRefineView();
            document.getElementById('refine-view').scrollTop = 0;
        }

        function updateRefineSummary() {
            const summary = document.getElementById('refine-summary');
            const entityCount = availableRefineEntities.length;
            const linkCount = availableRefineLinks.length;
            if (!entityCount && !linkCount) {
                summary.textContent = 'No new entities or links were suggested.';
            } else {
                summary.textContent = `${entityCount} new ${entityCount === 1 ? 'entity' : 'entities'} and ${linkCount} new ${linkCount === 1 ? 'link' : 'links'} available.`;
            }
            document.getElementById('apply-selected-button').disabled = entityCount === 0 && linkCount === 0;
            document.getElementById('apply-all-button').disabled = entityCount === 0 && linkCount === 0;
        }

        function renderEntitySuggestions() {
            const container = document.getElementById('refine-entities-list');
            container.innerHTML = '';
            if (!availableRefineEntities.length) {
                const empty = document.createElement('div');
                empty.className = 'refine-item-meta';
                empty.textContent = 'No new entities in this refinement.';
                container.appendChild(empty);
                return;
            }

            availableRefineEntities.forEach(entity => {
                const item = document.createElement('div');
                item.className = 'refine-entity-item';

                const header = document.createElement('label');
                header.className = 'refine-item-header';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = entity.id;
                checkbox.checked = selectedEntityAdditions.has(entity.id);
                checkbox.addEventListener('change', () => {
                    if (checkbox.checked) {
                        selectedEntityAdditions.add(entity.id);
                    } else {
                        selectedEntityAdditions.delete(entity.id);
                    }
                });

                const idSpan = document.createElement('span');
                idSpan.className = 'refine-item-id';
                idSpan.textContent = entity.id;

                header.appendChild(checkbox);
                header.appendChild(idSpan);

                const textSpan = document.createElement('div');
                textSpan.className = 'refine-item-text';
                textSpan.textContent = entity.text || '';

                item.appendChild(header);
                item.appendChild(textSpan);

                const linksForEntity = availableRefineLinks.filter(link => {
                    const involved = new Set([
                        ...(Array.isArray(link.entities) ? link.entities : []),
                        ...(Array.isArray(link.source_entities) ? link.source_entities : []),
                        ...(Array.isArray(link.target_entities) ? link.target_entities : []),
                    ]);
                    return involved.has(entity.id);
                });
                if (linksForEntity.length) {
                    const meta = document.createElement('div');
                    meta.className = 'refine-item-meta';
                    const linkIds = linksForEntity.map(link => link.id).join(', ');
                    meta.textContent = `Associated links: ${linkIds}`;
                    item.appendChild(meta);
                }
                container.appendChild(item);
            });
        }

        function renderLinkSuggestions() {
            const container = document.getElementById('refine-links-list');
            container.innerHTML = '';
            if (!availableRefineLinks.length) {
                const empty = document.createElement('div');
                empty.className = 'refine-item-meta';
                empty.textContent = 'No new links in this refinement.';
                container.appendChild(empty);
                return;
            }

            availableRefineLinks.forEach(link => {
                const item = document.createElement('div');
                item.className = 'refine-link-item';

                const header = document.createElement('label');
                header.className = 'refine-item-header';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = link.id;
                checkbox.checked = selectedLinkAdditions.has(link.id);
                checkbox.addEventListener('change', () => {
                    if (checkbox.checked) {
                        selectedLinkAdditions.add(link.id);
                    } else {
                        selectedLinkAdditions.delete(link.id);
                    }
                });

                const idSpan = document.createElement('span');
                idSpan.className = 'refine-item-id';
                idSpan.textContent = link.id;

                header.appendChild(checkbox);
                header.appendChild(idSpan);

                const textSpan = document.createElement('div');
                textSpan.className = 'refine-item-text';
                textSpan.textContent = link.line || '';

                item.appendChild(header);
                item.appendChild(textSpan);
                container.appendChild(item);
            });
        }

        window.runRefinement = async function() {
            if (isRefining) return;
            const content = document.getElementById('input').value;
            if (!content.trim()) {
                alert('Please provide CRT content before refining.');
                return;
            }

            isRefining = true;
            setRefineButtonState(true);
            const spinner = document.getElementById('refine-spinner');
            if (spinner) spinner.classList.add('visible');

            try {
                const response = await fetch(`${backendBaseUrl}/api/refine`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content })
                });

                if (!response.ok) {
                    const message = await response.text();
                    alert(`Refinement failed: ${message || response.statusText}`);
                    return;
                }

                const data = await response.json();
                lastRefineResult = data;
                renderRefinePreview(content, data);
            } catch (error) {
                console.error('Refinement request failed', error);
                alert(`Refinement failed: ${error.message || error}`);
            } finally {
                isRefining = false;
                setRefineButtonState(false);
                if (spinner) spinner.classList.remove('visible');
            }
        };

        window.closeRefineView = function() {
            hideRefineView();
            lastRefineResult = null;
            availableRefineEntities = [];
            availableRefineLinks = [];
            selectedEntityAdditions = new Set();
            selectedLinkAdditions = new Set();
        };

        function gatherEntitiesForLinks(linkIds) {
            const ids = new Set();
            linkIds.forEach(id => {
                const link = refineLinkMap.get(id);
                if (!link) return;
                [
                    ...(Array.isArray(link.entities) ? link.entities : []),
                    ...(Array.isArray(link.source_entities) ? link.source_entities : []),
                    ...(Array.isArray(link.target_entities) ? link.target_entities : []),
                ].forEach(entityId => {
                    if (entityId) {
                        ids.add(entityId);
                    }
                });
            });
            return ids;
        }

        function applyAdditions(entityIds, linkIds) {
            if (!entityIds.length && !linkIds.length) {
                alert('No entities or links selected to add.');
                return;
            }

            const textarea = document.getElementById('input');
            let content = textarea.value;
            const currentEntities = getCurrentEntityIds(content);
            const currentLinks = getCurrentLinkIds(content);

            const entitiesToAdd = entityIds.filter(id => !currentEntities.has(id));
            content = insertEntities(content, entitiesToAdd);

            const linksToAdd = linkIds.filter(id => !currentLinks.has(id));
            content = insertLinks(content, linksToAdd);

            textarea.value = content;
            updateLineNumbers();
            saveToLocalStorage();

            if (lastRefineResult) {
                renderRefinePreview(content, lastRefineResult);
            }
        }

        window.applySelectedAdditions = function() {
            if (!lastRefineResult) return;
            const finalEntitySet = new Set(selectedEntityAdditions);
            const finalLinkSet = new Set(selectedLinkAdditions);

            // Automatically include links associated with selected entities
            availableRefineLinks.forEach(link => {
                const involved = new Set([
                    ...(Array.isArray(link.entities) ? link.entities : []),
                    ...(Array.isArray(link.source_entities) ? link.source_entities : []),
                    ...(Array.isArray(link.target_entities) ? link.target_entities : []),
                ]);
                for (const entityId of finalEntitySet) {
                    if (involved.has(entityId)) {
                        finalLinkSet.add(link.id);
                        break;
                    }
                }
            });

            // Ensure entities for selected links are added
            const extraEntities = gatherEntitiesForLinks(finalLinkSet);
            extraEntities.forEach(id => finalEntitySet.add(id));

            applyAdditions(Array.from(finalEntitySet), Array.from(finalLinkSet));
        };

        window.applyAllAdditions = function() {
            if (!lastRefineResult) return;
            const allEntityIds = availableRefineEntities.map(entity => entity.id);
            const allLinkIds = availableRefineLinks.map(link => link.id);
            const combinedEntities = new Set(allEntityIds);
            gatherEntitiesForLinks(new Set(allLinkIds)).forEach(id => combinedEntities.add(id));
            applyAdditions(Array.from(combinedEntities), allLinkIds);
        };

        // Add these variables before your existing script code
        const physics = {
            default: {
                linkDistance: 250,
                chargeStrength: -1500,
                centerStrength: 1,
                xyStrength: 0.05,
                alpha: 1,
                alphaTarget: 0.3
            },
            branch: {
                linkDistance: 150,
                chargeStrength: -2000,
                alpha: 0.5
            }
        };

        let physicsEnabled = true;
        let simulation;

        // Replace your renderGraph function with this version
        function renderGraph(inputNodes, inputLinks) {
            // Create deep copies of the input data
            const nodes = JSON.parse(JSON.stringify(inputNodes));
            const links = JSON.parse(JSON.stringify(inputLinks));
            
            const container = document.querySelector('.visualization-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            const svg = d3.select('.visualization-container svg');
            svg.selectAll("*").remove();
            
            // Add zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });

            svg.call(zoom);
            
            // Create a group for graph elements
            const g = svg.append('g');
            
            // Create arrow markers
            const markerTypes = ['IF', 'THEN', 'AND'];
            const markerColors = {
                'IF': 'blue',
                'THEN': 'black',
                'AND': 'darkgreen'
            };

            svg.append('defs').selectAll('marker')
                .data(markerTypes)
                .enter()
                .append('marker')
                .attr('id', d => `arrow-${d}`)
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 35)
                .attr('refY', 0)
                .attr('markerWidth', 8)
                .attr('markerHeight', 8)
                .attr('orient', 'auto')
                .append('path')
                .attr('fill', d => markerColors[d])
                .attr('d', 'M0,-5L10,0L0,5');

            // Create the simulation
            simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(physics.default.linkDistance))
                .force('charge', d3.forceManyBody().strength(physics.default.chargeStrength))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('x', d3.forceX(width / 2).strength(physics.default.xyStrength))
                .force('y', d3.forceY(height / 2).strength(physics.default.xyStrength));

            // Create the links
            const link = g.append('g')
                .selectAll('line')
                .data(links)
                .enter()
                .append('line')
                .attr('class', d => `link ${d.type}${d.negated ? ' negated' : ''}`)
                .attr('marker-end', d => `url(#arrow-${d.type})`);

            // Create link labels
            const linkLabels = g.append('g')
                .selectAll('text')
                .data(links)
                .enter()
                .append('text')
                .attr('class', d => `link-label${d.negated ? ' negated' : ''}`)
                .text(d => d.label || d.type);

            // Create node groups
            const nodeGroup = g.append('g')
                .selectAll('.node-group')
                .data(nodes)
                .enter()
                .append('g')
                .attr('class', 'node-group')
                .call(d3.drag()
                    .on('start', dragStarted)
                    .on('drag', dragged)
                    .on('end', dragEnded))
                .on('click', focusOnNode);

            // Create circles for nodes
            const node = nodeGroup.append('circle')
                .attr('class', d => `node ${d.type || 'normal'}`)
                .attr('r', d => d.type === 'start' ? 50 : 40);

            // Create labels for nodes
            const nodeLabels = nodeGroup.append('text')
                .attr('class', 'node-label')
                .text(d => {
                    const maxLength = 20;
                    return d.text.length > maxLength ? d.text.substring(0, maxLength) + '...' : d.text;
                });

            // Update positions on each tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                nodeGroup.attr('transform', d => `translate(${d.x},${d.y})`);

                linkLabels
                    .attr('x', d => (d.source.x + d.target.x) / 2)
                    .attr('y', d => (d.source.y + d.target.y) / 2 - 5);
            });

            // Store the input data globally FIRST
            window.inputNodes = nodes;
            window.inputLinks = links;

            // Populate node list (now that links are available)
            populateNodeList(nodes, links);

            // Add event listeners for controls
            document.getElementById('search-box').addEventListener('input', () => searchNodes(nodes, links));
        }

        // Add function to calculate reachability metrics
        function calculateReachabilityMetrics(nodes, links) {
            console.log('calculateReachabilityMetrics called with:', {
                nodeCount: nodes.length,
                linkCount: links.length,
                sampleNode: nodes[0],
                sampleLink: links[0]
            });
            
            const reachabilityMap = new Map();
            
            nodes.forEach(node => {
                const reachableNodes = new Set();
                reachableNodes.add(node.id);
                
                function findReachableNodes(nodeId) {
                    const outgoingLinks = links.filter(link => {
                        const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                        const isMatch = sourceId === nodeId && (link.type === 'THEN' || link.type === 'AND');
                        return isMatch;
                    });
                    
                    console.log(`Node ${nodeId} has ${outgoingLinks.length} outgoing THEN/AND links`);
                    
                    outgoingLinks.forEach(link => {
                        const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                        if (!reachableNodes.has(targetId)) {
                            reachableNodes.add(targetId);
                            findReachableNodes(targetId);
                        }
                    });
                }
                
                findReachableNodes(node.id);
                // Subtract 1 to exclude the node itself from the count
                const count = reachableNodes.size - 1;
                console.log(`Node ${node.id} (${node.text.substring(0, 20)}...) can reach ${count} nodes`);
                reachabilityMap.set(node.id, count);
            });
            
            return reachabilityMap;
        }

        // Add function to calculate uniqueness metrics (nodes not reachable from higher-ranked nodes)
        function calculateUniquenessMetrics(nodes, links, reachabilityMap) {
            const uniquenessMap = new Map();
            
            // Sort nodes by reachability (descending) to establish ranking
            const sortedByReachability = [...nodes].sort((a, b) => {
                const aReach = reachabilityMap.get(a.id) || 0;
                const bReach = reachabilityMap.get(b.id) || 0;
                return bReach - aReach;
            });
            
            nodes.forEach(node => {
                // Find all nodes that can reach this node
                const nodesThatCanReachThis = new Set();
                
                // Check each other node to see if it can reach this node
                nodes.forEach(otherNode => {
                    if (otherNode.id === node.id) return; // Skip self
                    
                    // Calculate what this other node can reach
                    const reachableFromOther = new Set();
                    reachableFromOther.add(otherNode.id);
                    
                    function findReachableFromNode(nodeId) {
                        const outgoingLinks = links.filter(link => {
                            const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                            return sourceId === nodeId && (link.type === 'THEN' || link.type === 'AND');
                        });
                        
                        outgoingLinks.forEach(link => {
                            const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                            if (!reachableFromOther.has(targetId)) {
                                reachableFromOther.add(targetId);
                                findReachableFromNode(targetId);
                            }
                        });
                    }
                    
                    findReachableFromNode(otherNode.id);
                    
                    // If this other node can reach our target node, add it to the set
                    if (reachableFromOther.has(node.id)) {
                        nodesThatCanReachThis.add(otherNode.id);
                    }
                });
                
                // Now find how many nodes this node can reach that are NOT reachable from higher-ranked nodes
                const thisNodeCanReach = new Set();
                thisNodeCanReach.add(node.id);
                
                function findReachableFromThisNode(nodeId) {
                    const outgoingLinks = links.filter(link => {
                        const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                        return sourceId === nodeId && (link.type === 'THEN' || link.type === 'AND');
                    });
                    
                    outgoingLinks.forEach(link => {
                        const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                        if (!thisNodeCanReach.has(targetId)) {
                            thisNodeCanReach.add(targetId);
                            findReachableFromThisNode(targetId);
                        }
                    });
                }
                
                findReachableFromThisNode(node.id);
                
                // Find higher-ranked nodes (those with higher or equal reachability)
                const higherRankedNodes = sortedByReachability.filter(n => {
                    const nReach = reachabilityMap.get(n.id) || 0;
                    const nodeReach = reachabilityMap.get(node.id) || 0;
                    return n.id !== node.id && nReach >= nodeReach;
                });
                
                // Find what all higher-ranked nodes can reach combined
                const reachableFromHigherRanked = new Set();
                
                higherRankedNodes.forEach(higherNode => {
                    const reachableFromHigher = new Set();
                    reachableFromHigher.add(higherNode.id);
                    
                    function findReachableFromHigher(nodeId) {
                        const outgoingLinks = links.filter(link => {
                            const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                            return sourceId === nodeId && (link.type === 'THEN' || link.type === 'AND');
                        });
                        
                        outgoingLinks.forEach(link => {
                            const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                            if (!reachableFromHigher.has(targetId)) {
                                reachableFromHigher.add(targetId);
                                findReachableFromHigher(targetId);
                            }
                        });
                    }
                    
                    findReachableFromHigher(higherNode.id);
                    
                    // Add all reachable nodes to the combined set
                    reachableFromHigher.forEach(id => reachableFromHigherRanked.add(id));
                });
                
                // Count nodes that this node can reach but higher-ranked nodes cannot
                let uniqueReachableCount = 0;
                thisNodeCanReach.forEach(reachableId => {
                    if (reachableId !== node.id && !reachableFromHigherRanked.has(reachableId)) {
                        uniqueReachableCount++;
                    }
                });
                
                console.log(`Node ${node.id} (${node.text.substring(0, 20)}...) has ${uniqueReachableCount} unique reachable nodes`);
                uniquenessMap.set(node.id, uniqueReachableCount);
            });
            
            return uniquenessMap;
        }

        // Add these helper functions
        function populateNodeList(nodes, links = null) {
            const nodeList = document.querySelector('.node-list');
            nodeList.innerHTML = '';
            
            // Calculate reachability metrics using the original input links
            const linksToUse = window.inputLinks || links || [];
            console.log('populateNodeList - linksToUse:', linksToUse);
            console.log('populateNodeList - window.inputLinks:', window.inputLinks);
            console.log('populateNodeList - links parameter:', links);
            
            const reachabilityMap = calculateReachabilityMetrics(nodes, linksToUse);
            const uniquenessMap = calculateUniquenessMetrics(nodes, linksToUse, reachabilityMap);
            
            // Sort nodes by reachability count (descending), then by type (start first), then alphabetically
            const sortedNodes = [...nodes].sort((a, b) => {
                // First, prioritize start nodes
                if (a.type === 'start' && b.type !== 'start') return -1;
                if (b.type === 'start' && a.type !== 'start') return 1;
                
                // Then sort by reachability count (descending)
                const aReachability = reachabilityMap.get(a.id) || 0;
                const bReachability = reachabilityMap.get(b.id) || 0;
                if (aReachability !== bReachability) {
                    return bReachability - aReachability;
                }
                
                // Finally, sort alphabetically
                return a.text.localeCompare(b.text);
            });

            sortedNodes.forEach(node => {
                const nodeItem = document.createElement('div');
                nodeItem.className = `node-item ${node.type || 'normal'}`;
                nodeItem.dataset.id = node.id;
                
                // Create the content with both metrics
                const reachabilityCount = reachabilityMap.get(node.id) || 0;
                const uniquenessCount = uniquenessMap.get(node.id) || 0;
                
                const textSpan = document.createElement('span');
                textSpan.className = 'node-text';
                textSpan.textContent = node.text;
                
                const metricsContainer = document.createElement('div');
                metricsContainer.className = 'metrics-container';
                
                const reachabilitySpan = document.createElement('span');
                reachabilitySpan.className = 'reachability-count';
                reachabilitySpan.textContent = reachabilityCount;
                reachabilitySpan.title = 'Total reachable nodes';
                
                const uniquenessSpan = document.createElement('span');
                uniquenessSpan.className = 'uniqueness-count';
                uniquenessSpan.textContent = uniquenessCount;
                uniquenessSpan.title = 'Unique reachable nodes (not reachable from higher-ranked nodes)';
                
                metricsContainer.appendChild(reachabilitySpan);
                metricsContainer.appendChild(uniquenessSpan);
                
                nodeItem.appendChild(textSpan);
                nodeItem.appendChild(metricsContainer);
                
                nodeItem.addEventListener('click', function() {
                    if (this.classList.contains('selected-primary')) {
                        // If clicking selected node, reset the graph
                        resetGraph();
                    } else {
                        // Otherwise, focus on the selected node
                        focusOnNode(null, node);
                    }
                });
                nodeList.appendChild(nodeItem);
            });
        }

        function focusOnNode(event, d) {
            if (!d) return;
            
            // Check if this node is already selected
            const nodeItem = document.querySelector(`.node-item[data-id="${d.id}"]`);
            const isAlreadySelected = nodeItem && nodeItem.classList.contains('selected-primary');
            
            // If the node is already selected, reset the graph
            if (isAlreadySelected) {
                resetGraph();
                document.getElementById('branch-panel').classList.remove('visible');
                return;
            }
            
            // Get current simulation nodes and links
            const currentNodes = simulation.nodes();
            const currentLinks = simulation.force('link').links();
            
            // Update the selected node in the list
            document.querySelectorAll('.node-item').forEach(item => {
                item.classList.remove('selected-primary');
                item.classList.remove('selected-branch');
            });
            
            if (nodeItem) {
                nodeItem.classList.add('selected-primary');
                nodeItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
            
            // Find all reachable nodes from the selected node
            const reachableNodes = new Set();
            reachableNodes.add(d.id);
            
            function findReachableNodes(nodeId) {
                const outgoingLinks = currentLinks.filter(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    return sourceId === nodeId && (link.type === 'THEN' || link.type === 'AND');
                });
                
                outgoingLinks.forEach(link => {
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    if (!reachableNodes.has(targetId)) {
                        reachableNodes.add(targetId);
                        findReachableNodes(targetId);
                    }
                });
            }
            
            findReachableNodes(d.id);
            
            // Filter nodes and links
            const filteredNodes = currentNodes.filter(node => reachableNodes.has(node.id));
            const filteredLinks = currentLinks.filter(link => {
                const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                return reachableNodes.has(sourceId) && reachableNodes.has(targetId);
            });
            
            // ----- Find all possible paths -----
            const allPaths = findAllPaths(d, filteredNodes, filteredLinks);
            
            // ----- Populate the branch panel -----
            populateBranchPanel(d, allPaths);
            
            // ----- Update the visualization -----
            // Clear the existing visualization
            const svg = d3.select('.visualization-container svg');
            const g = svg.select('g');
            
            // Remove all existing elements
            g.selectAll('.link').remove();
            g.selectAll('.link-label').remove();
            g.selectAll('.node-group').remove();
            
            // Create new elements with filtered data
            // Links
            const link = g.append('g')
                .selectAll('line')
                .data(filteredLinks)
                .enter()
                .append('line')
                .attr('class', d => `link ${d.type}${d.negated ? ' negated' : ''}`)
                .attr('marker-end', d => `url(#arrow-${d.type})`);

            // Link labels
            const linkLabels = g.append('g')
                .selectAll('text')
                .data(filteredLinks)
                .enter()
                .append('text')
                .attr('class', d => `link-label${d.negated ? ' negated' : ''}`)
                .text(d => d.label || d.type);
            
            // Node groups
            const nodeGroup = g.append('g')
                .selectAll('.node-group')
                .data(filteredNodes)
                .enter()
                .append('g')
                .attr('class', 'node-group')
                .call(d3.drag()
                    .on('start', dragStarted)
                    .on('drag', dragged)
                    .on('end', dragEnded))
                .on('click', focusOnNode);
            
            // Circles for nodes - with highlighting
            nodeGroup.append('circle')
                .attr('class', function(node) {
                    if (node.id === d.id) {
                        return `node ${node.type || 'normal'} highlighted-primary`;
                    } else {
                        return `node ${node.type || 'normal'} highlighted-branch`;
                    }
                })
                .attr('r', d => d.type === 'start' ? 50 : 40);
            
            // Labels for nodes
            nodeGroup.append('text')
                .attr('class', 'node-label')
                .text(d => {
                    const maxLength = 20;
                    return d.text.length > maxLength ? d.text.substring(0, maxLength) + '...' : d.text;
                });
            
            // Update node list highlighting
            document.querySelectorAll('.node-item').forEach(item => {
                const nodeId = parseInt(item.dataset.id);
                if (nodeId === d.id) {
                    item.classList.add('selected-primary');
                } else if (reachableNodes.has(nodeId)) {
                    item.classList.add('selected-branch');
                }
            });
            
            // Update simulation
            simulation.nodes(filteredNodes);
            simulation.force('link').links(filteredLinks);
            
            // Update positions on each tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
            
                nodeGroup.attr('transform', d => `translate(${d.x},${d.y})`);
            
                linkLabels
                    .attr('x', d => (d.source.x + d.target.x) / 2)
                    .attr('y', d => (d.source.y + d.target.y) / 2 - 5);
            });
            
            // Restart the simulation
            simulation.alpha(1).restart();
        }

        // Helper function to find all possible paths from the selected node
        function findAllPaths(startNode, nodes, links) {
            // Find all paths through THEN relationships
            function findPathsFromNode(nodeId, visited = new Set(), currentPath = []) {
                visited.add(nodeId);
                
                // Add current node to path
                const node = nodes.find(n => n.id === nodeId);
                currentPath.push(node);
                
                // Find all outgoing THEN links
                const outgoingLinks = links.filter(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    return sourceId === nodeId && (link.type === 'THEN' || link.type === 'AND');
                });
                
                // If no outgoing links, this is the end of a path
                if (outgoingLinks.length === 0) {
                    return [currentPath];
                }
                
                let allPaths = [];
                
                // Follow each outgoing link
                for (const link of outgoingLinks) {
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    
                    // Skip if we've visited this node (avoid cycles)
                    if (visited.has(targetId)) continue;
                    
                    // Create a new path that includes this link
                    const newPath = [...currentPath];
                    newPath.push(link); // Add the link to the path
                    
                    // Continue from the target node
                    const pathsFromHere = findPathsFromNode(targetId, new Set([...visited]), newPath);
                    allPaths = [...allPaths, ...pathsFromHere];
                }
                
                return allPaths.length > 0 ? allPaths : [currentPath];
            }
            
            // Start from the selected node
            return findPathsFromNode(startNode.id);
        }

        // Function to populate the branch panel with tabs for each path
        function populateBranchPanel(selectedNode, allPaths) {
            const branchPanel = document.getElementById('branch-panel');
            const branchContent = document.getElementById('branch-content');
            branchContent.innerHTML = '';
            
            // Make the branch panel visible
            branchPanel.classList.add('visible');
            
            if (allPaths.length > 0) {
                // Create tabs container
                const tabsContainer = document.createElement('div');
                tabsContainer.className = 'tabs';
                branchContent.appendChild(tabsContainer);
                
                // Tab content container
                const tabContentsContainer = document.createElement('div');
                branchContent.appendChild(tabContentsContainer);
                
                // Create tabs and content for each path
                for (let pathIndex = 0; pathIndex < allPaths.length; pathIndex++) {
                    const path = allPaths[pathIndex];
                    
                    // Create a tab for this path
                    const tab = document.createElement('div');
                    tab.className = 'tab';
                    if (pathIndex === 0) tab.classList.add('active');
                    tab.textContent = `${pathIndex + 1}`;
                    tab.dataset.path = pathIndex;
                    tabsContainer.appendChild(tab);
                    
                    // Create content container for this path
                    const tabContent = document.createElement('div');
                    tabContent.className = 'tab-content';
                    if (pathIndex === 0) tabContent.classList.add('active');
                    tabContent.dataset.path = pathIndex;
                    tabContentsContainer.appendChild(tabContent);
                    
                    // Add the IF title at the top
                    const ifTitle = document.createElement('h3');
                    ifTitle.textContent = 'IF';
                    tabContent.appendChild(ifTitle);
                    
                    // Add the selected node
                    const selectedNodeDiv = document.createElement('div');
                    selectedNodeDiv.className = 'branch-item branch-node primary';
                    selectedNodeDiv.textContent = selectedNode.text;
                    tabContent.appendChild(selectedNodeDiv);
                    
                    // Process the path
                    let lastItem = null;
                    for (let i = 1; i < path.length; i++) {
                        const item = path[i];
                        
                        // If it's a node
                        if (item && item.id !== undefined) {
                            // Add a node item
                            const nodeDiv = document.createElement('div');
                            nodeDiv.className = 'branch-item branch-node';
                            nodeDiv.textContent = item.text;
                            tabContent.appendChild(nodeDiv);
                            lastItem = 'node';
                        } 
                        // If it's a link and the last item wasn't a relationship
                        else if (item && item.type && lastItem !== 'relationship') {
                            // Add a relationship item
                            const relDiv = document.createElement('div');
                            relDiv.className = 'branch-item branch-relationship';
                            const relLabel = item.label
                                || `${item.type}${item.targetNegated ? ' NOT' : ''}`;
                            relDiv.textContent = relLabel;
                            tabContent.appendChild(relDiv);
                            lastItem = 'relationship';
                        }
                    }
                }
                
                // Add click handlers to tabs with auto-scrolling
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', function() {
                        // Remove active class from all tabs and contents
                        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                        
                        // Add active class to this tab and its content
                        this.classList.add('active');
                        document.querySelector(`.tab-content[data-path="${this.dataset.path}"]`).classList.add('active');
                        
                        // Auto-scroll the tab into view (centered if possible)
                        const tabsContainer = document.querySelector('.tabs');
                        const tabElement = this;
                        
                        // Calculate position to center the tab
                        const containerWidth = tabsContainer.clientWidth;
                        const tabWidth = tabElement.clientWidth;
                        const tabLeft = tabElement.offsetLeft;
                        
                        // Center the tab in view
                        const scrollPosition = tabLeft - (containerWidth / 2) + (tabWidth / 2);
                        
                        // Smooth scroll to position
                        tabsContainer.scrollTo({
                            left: Math.max(0, scrollPosition),
                            behavior: 'smooth'
                        });
                    });
                });
            }
        }

        function dragStarted(event, d) {
            if (!event.active && physicsEnabled) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragEnded(event, d) {
            if (!event.active && physicsEnabled) simulation.alphaTarget(0);
        }

        function searchNodes(nodes, links) {
            const searchText = document.getElementById('search-box').value.toLowerCase();
            document.querySelectorAll('.node-item').forEach(item => {
                const matchesSearch = item.textContent.toLowerCase().includes(searchText);
                item.style.display = matchesSearch ? 'block' : 'none';
            });
        }

        async function initWasm() {
            await init();
            wasmReady = true;
            try {
                const response = await fetch('CRT.neo');
                const content = await response.text();
                document.getElementById('input').value = content;
                updateLineNumbers();
            } catch (error) {
                console.error('Error loading CRT.neo:', error);
                scheduleViewToggleValidation();
            }
        }

        initWasm();

        document.querySelectorAll('.edit-tab-button').forEach((button) => {
            button.addEventListener('click', () => setActiveEditTab(button.dataset.editTab));
        });
        applyActiveEditTab();
        document.querySelectorAll('[data-time-category]').forEach((input) => {
            const category = input.dataset.timeCategory;
            if (!category) {
                return;
            }
            const handler = () => applyManualTimeAllocation(category, input.value);
            input.addEventListener('input', handler);
            input.addEventListener('change', handler);
        });
        document.querySelectorAll('[data-time-slider]').forEach((slider) => {
            const category = slider.dataset.timeSlider;
            if (!category) {
                return;
            }
            const handler = () => applyManualTimeAllocation(category, slider.value);
            slider.addEventListener('input', handler);
            slider.addEventListener('change', handler);
        });
        document.querySelectorAll('[data-time-lock]').forEach((lock) => {
            const category = lock.dataset.timeLock;
            if (!category) {
                return;
            }
            setLockState(category, lock.checked);
            lock.addEventListener('change', () => {
                setLockState(category, lock.checked);
                if (!lock.checked) {
                    distributeUnlocked();
                }
                updateTimeAllocationSummary();
                markAnalysisStale();
                updateAnalysisAvailability();
            });
        });
        const pbisInput = document.getElementById('pbis-per-sprint');
        if (pbisInput) {
            const notify = () => {
                markAnalysisStale();
                updateAnalysisAvailability();
            };
            pbisInput.addEventListener('input', notify);
            pbisInput.addEventListener('change', notify);
        }
        const analysisButton = document.getElementById('analysis-refresh-button');
        if (analysisButton) {
            analysisButton.addEventListener('click', () => runAnalysis(true));
        }
        updateTimeAllocationSummary();
        initializeWestrumScale();
        initializeDoraTable();
        updateAnalysisAvailability();
        window.getDoraSelections = () => {
            const selections = {};
            DORA_ALL_METRICS.forEach((metric) => {
                selections[metric] = doraSelections[metric] ?? null;
            });
            const input = document.getElementById('pbis-per-sprint');
            const raw = input ? input.value.trim() : '';
            const parsed = raw === '' ? null : Number.parseFloat(raw);
            selections.pbis_per_sprint_per_team =
                parsed !== null && Number.isFinite(parsed) ? parsed : null;
            return selections;
        };
        window.getWestrumScore = () => Number(document.getElementById('westrum-scale')?.value ?? 0);

        const textarea = document.getElementById('input');
        textarea.addEventListener('input', () => {
            updateLineNumbers();
            markAnalysisStale();
            updateAnalysisAvailability();
        });
        textarea.addEventListener('scroll', function(e) {
            document.getElementById('line-numbers').scrollTop = e.target.scrollTop;
        });
        
        textarea.addEventListener('keydown', function(e) {
            if (e.key === 'Tab') {
                e.preventDefault();
                const start = this.selectionStart;
                const end = this.selectionEnd;
                this.value = this.value.substring(0, start) + '    ' + this.value.substring(end);
                this.selectionStart = this.selectionEnd = start + 4;
            }
        });

        function resetGraph() {
            // Remove highlighting from node list
            document.querySelectorAll('.node-item').forEach(item => {
                item.classList.remove('selected-primary');
                item.classList.remove('selected-branch');
            });

            // Hide the branch panel
            document.getElementById('branch-panel').classList.remove('visible');
            
            // Simply call updateVisualization to redraw the entire graph
            updateVisualization();
        }

        // Update localStorage functionality for auto-save and sidebar menu
        function initLocalStorage() {
            // Add an auto-save indicator
            const autoSaveIndicator = document.createElement('div');
            autoSaveIndicator.className = 'auto-save-indicator';
            autoSaveIndicator.textContent = 'Saving...';
            document.body.appendChild(autoSaveIndicator);
            
            // Set up auto-save timer (save every 2 seconds if there are changes)
            const textarea = document.getElementById('input');
            const title = document.getElementById('editor-title');
            let lastContent = textarea.value;
            let lastTitle = title.innerText;
            
            setInterval(() => {
                if (textarea.value !== lastContent || title.innerText !== lastTitle) {
                    saveToLocalStorage();
                    lastContent = textarea.value;
                    lastTitle = title.innerText;
                    
                    // Show auto-save indicator
                    autoSaveIndicator.classList.add('visible');
                    setTimeout(() => {
                        autoSaveIndicator.classList.remove('visible');
                    }, 1000);
                }
            }, 2000); // 2 seconds
            
            // Save when switching to visualization mode
            const originalToggleView = window.toggleView;
            window.toggleView = function() {
                saveToLocalStorage();
                originalToggleView();
            };
            
            // Load saved documents list for the sidebar
            updateSavedDocumentsList();
            
            // Find and load the most recently edited document
            loadMostRecentDocument();
            
            // Set up menu button functionality
            document.getElementById('menu-button').addEventListener('click', openSidebar);
            document.getElementById('close-menu').addEventListener('click', closeSidebar);
            document.getElementById('sidebar-overlay').addEventListener('click', closeSidebar);
            
            // Update sidebar when title changes
            document.getElementById('editor-title').addEventListener('blur', function() {
                if (document.getElementById('sidebar').classList.contains('open')) {
                    updateSavedDocumentsList();
                }
            });
        }

        // Open sidebar menu
        function openSidebar() {
            document.getElementById('sidebar').classList.add('open');
            document.getElementById('sidebar-overlay').classList.add('open');
            updateSavedDocumentsList(); // Refresh the list when opening
        }

        // Close sidebar menu
        function closeSidebar() {
            document.getElementById('sidebar').classList.remove('open');
            document.getElementById('sidebar-overlay').classList.remove('open');
        }

        // Update the list of saved documents in the sidebar
        function updateSavedDocumentsList() {
            const savedDocs = JSON.parse(localStorage.getItem('savedCRTDocuments') || '{}');
            const docsListElement = document.getElementById('saved-docs-list');
            docsListElement.innerHTML = '';
            
            // Get current document title
            const currentTitle = document.getElementById('editor-title').innerText.trim();
            
            // Convert to array for sorting
            const documents = Object.entries(savedDocs).map(([title, data]) => ({
                title,
                lastEdited: data.lastEdited || '0',
                content: data.content,
                isCurrent: title === currentTitle
            }));
            
            // Sort by last edited (most recent first)
            documents.sort((a, b) => new Date(b.lastEdited) - new Date(a.lastEdited));
            
            if (documents.length === 0) {
                const emptyMsg = document.createElement('div');
                emptyMsg.className = 'doc-item-empty';
                emptyMsg.textContent = 'No saved documents yet';
                emptyMsg.style.padding = '15px';
                emptyMsg.style.color = '#aaa';
                emptyMsg.style.textAlign = 'center';
                docsListElement.appendChild(emptyMsg);
                return;
            }
            
            // Create document list items
            documents.forEach(doc => {
                const docItem = document.createElement('div');
                docItem.className = doc.isCurrent ? 'doc-item current' : 'doc-item';
                
                const titleElement = document.createElement('div');
                titleElement.className = 'doc-item-title';
                titleElement.textContent = doc.title;
                
                const dateElement = document.createElement('div');
                dateElement.className = 'doc-item-date';
                dateElement.textContent = new Date(doc.lastEdited).toLocaleString();
                
                docItem.appendChild(titleElement);
                docItem.appendChild(dateElement);
                
                // Add click handler only for non-current documents
                if (!doc.isCurrent) {
                    docItem.addEventListener('click', () => {
                        loadFromLocalStorage(doc.title);
                        closeSidebar();
                    });
                }
                
                docsListElement.appendChild(docItem);
            });
        }

        // Save current document to localStorage
        function saveToLocalStorage() {
            const title = document.getElementById('editor-title').innerText.trim();
            const content = document.getElementById('input').value;
            
            // Don't save if title or content is empty
            if (!title || !content) return;
            
            // Get existing documents or create new map
            let savedDocs = JSON.parse(localStorage.getItem('savedCRTDocuments') || '{}');
            
            // Current timestamp
            const timestamp = new Date().toISOString();
            
            // Add current document
            savedDocs[title] = {
                content: content,
                lastEdited: timestamp
            };
            
            // Save back to localStorage
            localStorage.setItem('savedCRTDocuments', JSON.stringify(savedDocs));
        }

        // Load a document from localStorage
        function loadFromLocalStorage(title) {
            const savedDocs = JSON.parse(localStorage.getItem('savedCRTDocuments') || '{}');
            
            if (savedDocs[title]) {
                document.getElementById('editor-title').innerText = title;
                document.getElementById('input').value = savedDocs[title].content;
                updateLineNumbers();
                
                // Update the sidebar if it's open
                if (document.getElementById('sidebar').classList.contains('open')) {
                    updateSavedDocumentsList();
                }
            }
        }

        // Find and load the most recently edited document
        function loadMostRecentDocument() {
            const savedDocs = JSON.parse(localStorage.getItem('savedCRTDocuments') || '{}');
            const titles = Object.keys(savedDocs);
            
            if (titles.length === 0) return;
            
            // Find the document with the most recent lastEdited timestamp
            let mostRecentTitle = titles[0];
            let mostRecentTime = new Date(savedDocs[mostRecentTitle].lastEdited || 0).getTime();
            
            for (let i = 1; i < titles.length; i++) {
                const docTime = new Date(savedDocs[titles[i]].lastEdited || 0).getTime();
                if (docTime > mostRecentTime) {
                    mostRecentTime = docTime;
                    mostRecentTitle = titles[i];
                }
            }
            
            // Load the most recent document
            loadFromLocalStorage(mostRecentTitle);
        }

        // Call init function on page load
        document.addEventListener('DOMContentLoaded', function() {
            initLocalStorage();
        });
    </script>
</body>
</html> 
